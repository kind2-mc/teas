//! Oracle for lustre node `system` (see [System](struct.System.html)).
//!
//! Code generated by the [Kind 2 model checker][kind 2].
//!
//! [kind 2]: http://kind2-mc.github.io/kind2/ (The Kind 2 model checker)

// Deactiving lint warnings the transformation does not respect.
#![allow(
  non_upper_case_globals, non_snake_case, non_camel_case_types,
  unused_variables, unused_parens
)]

use helpers::* ;

/// Entry point.
fn main() {
  clap_and_run()
}


/// Stores the state for the oracle for **top node** `system`.
///
/// # Inputs
///
/// | Lustre identifier | Type | Source |
/// |:---:|:---:|:---|
/// | `time_base` | Bool | ghost |
/// | `handle_up` | Bool | input |
/// | `handle_down` | Bool | input |
/// | `gear_1_shock_absorber` | Bool | input |
/// | `gear_2_shock_absorber` | Bool | input |
/// | `gear_3_shock_absorber` | Bool | input |
/// | `general_EV` | Bool | output |
/// | `extend_EV` | Bool | output |
/// | `retract_EV` | Bool | output |
/// | `close_EV` | Bool | output |
/// | `open_EV` | Bool | output |
/// | `door_closed` | Bool | ghost |
/// | `door_open` | Bool | ghost |
/// | `gear_extended` | Bool | ghost |
/// | `gear_retracted` | Bool | ghost |
/// | `gear_maneuvering` | Bool | output |
/// | `door_maneuvering` | Bool | output |
/// | `pressurized` | Bool | output |
/// | `closed_ana` | Bool | output |
/// | `anomaly` | Bool | output |
///
/// # Outputs
///
/// The outputs of the oracle are the guarantees of the original
/// system and the implications for each require of each mode.
      ///
/// That is, if a mode has requires `req_1`, ..., `req_n` and ensures
/// `ens_1`, ..., `ens_m` this will generate `m` outputs:
///
/// - `(req_1 && ... && req_n) => ens_1`
      /// - ...
      /// - `(req_1 && ... && req_n) => ens_n`
      ///
/// Hence, an ensure output is false iff the mode is active and the
      /// ensure is false.
      ///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `r74` | Bool |
/// | `r73` | Bool |
/// | `r72` | Bool |
/// | `r71` | Bool |
/// | `r64` | Bool |
/// | `r63` | Bool |
/// | `r62` | Bool |
/// | `r61` | Bool |
/// | `r50` | Bool |
/// | `r42` | Bool |
/// | `r41` | Bool |
/// | `r32` | Bool |
/// | `r31` | Bool |
/// | `abs_36` | Bool |
/// | `abs_35` | Bool |
/// | `abs_34` | Bool |
/// | `abs_33` | Bool |
/// | `abs_32` | Bool |
/// | `abs_31` | Bool |
/// | `abs_30` | Bool |
/// | `abs_29` | Bool |
/// | `mode_R22_up_1` | Bool |
/// | `mode_R21_down_1` | Bool |
/// | `mode_R12_transient_4` | Bool |
/// | `mode_R12_transient_3` | Bool |
/// | `mode_R12_transient_2` | Bool |
/// | `mode_R12_transient_1` | Bool |
/// | `mode_R11_transient_4` | Bool |
/// | `mode_R11_transient_3` | Bool |
/// | `mode_R11_transient_2` | Bool |
/// | `mode_R11_transient_1` | Bool |
/// | `mode_R12_2` | Bool |
/// | `mode_R12_1` | Bool |
/// | `mode_R11_2` | Bool |
/// | `mode_R11_1` | Bool |
/// | `mode_waiting_4` | Bool |
/// | `mode_waiting_3` | Bool |
/// | `mode_waiting_2` | Bool |
/// | `mode_waiting_1` | Bool |
/// | `mode_extended_stable_1` | Bool |
/// | `mode_retracted_stable_1` | Bool |
/// | `mode_closed_stable_1` | Bool |
/// | `mode_open_stable_1` | Bool |
///
/// ## Guarantees
///
/// | Lustre identifier | Assumption number | Position |
/// |:---:|:---:|:---|
/// | `r74` | 13 | spec.lus line 435 col. 2 |
/// | `r73` | 12 | spec.lus line 434 col. 2 |
/// | `r72` | 11 | spec.lus line 433 col. 2 |
/// | `r71` | 10 | spec.lus line 432 col. 2 |
/// | `r64` | 9 | spec.lus line 430 col. 2 |
/// | `r63` | 8 | spec.lus line 429 col. 2 |
/// | `r62` | 7 | spec.lus line 428 col. 2 |
/// | `r61` | 6 | spec.lus line 427 col. 2 |
/// | `r50` | 5 | spec.lus line 425 col. 2 |
/// | `r42` | 4 | spec.lus line 423 col. 2 |
/// | `r41` | 3 | spec.lus line 422 col. 2 |
/// | `r32` | 2 | spec.lus line 420 col. 2 |
/// | `r31` | 1 | spec.lus line 419 col. 2 |
/// | `abs_36` | 8 | spec.lus line 352 col. 2 |
/// | `abs_35` | 7 | spec.lus line 350 col. 2 |
/// | `abs_34` | 6 | spec.lus line 348 col. 2 |
/// | `abs_33` | 5 | spec.lus line 347 col. 2 |
/// | `abs_32` | 4 | spec.lus line 346 col. 2 |
/// | `abs_31` | 3 | spec.lus line 345 col. 2 |
/// | `abs_30` | 2 | spec.lus line 341 col. 2 |
/// | `abs_29` | 1 | spec.lus line 338 col. 2 |

          ///
/// ## Mode **R22_up**
///
/// Position: *spec.lus line 414 col. 2*.
///
/// | Lustre identifier | Mode require number | Position |
/// |:---:|:---:|:---|
/// | `abs_46` | 1 | spec.lus line 416 col. 4 |

              
///
/// ## Mode **R21_down**
///
/// Position: *spec.lus line 410 col. 2*.
///
/// | Lustre identifier | Mode require number | Position |
/// |:---:|:---:|:---|
/// | `abs_45` | 1 | spec.lus line 412 col. 4 |

              
///
/// ## Mode **R12_transient**
///
/// Position: *spec.lus line 402 col. 2*.
///
/// | Lustre identifier | Mode require number | Position |
/// |:---:|:---:|:---|
/// | `abs_62` | 4 | spec.lus line 407 col. 4 |
/// | `abs_61` | 3 | spec.lus line 406 col. 4 |
/// | `abs_60` | 2 | spec.lus line 405 col. 4 |
/// | `abs_59` | 1 | spec.lus line 404 col. 4 |

              
///
/// ## Mode **R11_transient**
///
/// Position: *spec.lus line 394 col. 2*.
///
/// | Lustre identifier | Mode require number | Position |
/// |:---:|:---:|:---|
/// | `abs_57` | 4 | spec.lus line 399 col. 4 |
/// | `abs_56` | 3 | spec.lus line 398 col. 4 |
/// | `abs_55` | 2 | spec.lus line 397 col. 4 |
/// | `abs_54` | 1 | spec.lus line 396 col. 4 |

              
///
/// ## Mode **R12**
///
/// Position: *spec.lus line 387 col. 2*.
///
/// | Lustre identifier | Mode require number | Position |
/// |:---:|:---:|:---|
/// | `abs_50` | 2 | spec.lus line 391 col. 4 |
/// | `abs_52` | 1 | spec.lus line 390 col. 4 |

              
///
/// ## Mode **R11**
///
/// Position: *spec.lus line 380 col. 2*.
///
/// | Lustre identifier | Mode require number | Position |
/// |:---:|:---:|:---|
/// | `abs_50` | 2 | spec.lus line 384 col. 4 |
/// | `abs_49` | 1 | spec.lus line 383 col. 4 |

              
///
/// ## Mode **waiting**
///
/// Position: *spec.lus line 371 col. 2*.
///
/// | Lustre identifier | Mode require number | Position |
/// |:---:|:---:|:---|
/// | `abs_46` | 4 | spec.lus line 377 col. 4 |
/// | `abs_45` | 3 | spec.lus line 376 col. 4 |
/// | `abs_44` | 2 | spec.lus line 375 col. 4 |
/// | `abs_43` | 1 | spec.lus line 374 col. 4 |

              
///
/// ## Mode **extended_stable**
///
/// Position: *spec.lus line 366 col. 2*.
///
/// | Lustre identifier | Mode require number | Position |
/// |:---:|:---:|:---|
/// | `gear_extended` | 1 | spec.lus line 368 col. 4 |

              
///
/// ## Mode **retracted_stable**
///
/// Position: *spec.lus line 362 col. 2*.
///
/// | Lustre identifier | Mode require number | Position |
/// |:---:|:---:|:---|
/// | `gear_retracted` | 1 | spec.lus line 364 col. 4 |

              
///
/// ## Mode **closed_stable**
///
/// Position: *spec.lus line 358 col. 2*.
///
/// | Lustre identifier | Mode require number | Position |
/// |:---:|:---:|:---|
/// | `door_closed` | 1 | spec.lus line 360 col. 4 |

              
///
/// ## Mode **open_stable**
///
/// Position: *spec.lus line 354 col. 2*.
///
/// | Lustre identifier | Mode require number | Position |
/// |:---:|:---:|:---|
/// | `door_open` | 1 | spec.lus line 356 col. 4 |

              
///
/// # Assumptions
///
/// | State variable | Position | Number |
/// |:------:|:-----:|:-----:|
/// | `abs_20` | spec.lus line 316 col. 2 | 1 |
/// | `abs_21` | spec.lus line 317 col. 2 | 2 |
/// | `abs_22` | spec.lus line 318 col. 2 | 3 |
/// | `abs_23` | spec.lus line 319 col. 2 | 4 |
/// | `abs_24` | spec.lus line 321 col. 2 | 5 |
/// | `time_base` | spec.lus line 327 col. 2 | 6 |
/// | `abs_26` | spec.lus line 329 col. 2 | 7 |
/// | `abs_28` | spec.lus line 332 col. 2 | 8 |
///
pub struct System {
  /// Input: `system.usr.time_base`
  pub svar_time_base: Bool,
  /// Input: `system.usr.handle_up`
  pub svar_handle_up: Bool,
  /// Input: `system.usr.handle_down`
  pub svar_handle_down: Bool,
  /// Input: `system.usr.gear_1_shock_absorber`
  pub svar_gear_1_shock_absorber: Bool,
  /// Input: `system.usr.gear_2_shock_absorber`
  pub svar_gear_2_shock_absorber: Bool,
  /// Input: `system.usr.gear_3_shock_absorber`
  pub svar_gear_3_shock_absorber: Bool,
  /// Input: `system.usr.general_EV`
  pub svar_general_EV: Bool,
  /// Input: `system.usr.extend_EV`
  pub svar_extend_EV: Bool,
  /// Input: `system.usr.retract_EV`
  pub svar_retract_EV: Bool,
  /// Input: `system.usr.close_EV`
  pub svar_close_EV: Bool,
  /// Input: `system.usr.open_EV`
  pub svar_open_EV: Bool,
  /// Input: `system.usr.door_closed`
  pub svar_door_closed: Bool,
  /// Input: `system.usr.door_open`
  pub svar_door_open: Bool,
  /// Input: `system.usr.gear_extended`
  pub svar_gear_extended: Bool,
  /// Input: `system.usr.gear_retracted`
  pub svar_gear_retracted: Bool,
  /// Input: `system.usr.gear_maneuvering`
  pub svar_gear_maneuvering: Bool,
  /// Input: `system.usr.door_maneuvering`
  pub svar_door_maneuvering: Bool,
  /// Input: `system.usr.pressurized`
  pub svar_pressurized: Bool,
  /// Input: `system.usr.closed_ana`
  pub svar_closed_ana: Bool,
  /// Input: `system.usr.anomaly`
  pub svar_anomaly: Bool,

  /// Output: `system.contract.usr.r74`
  pub svar_r74: Bool,
  /// Output: `system.contract.usr.r73`
  pub svar_r73: Bool,
  /// Output: `system.contract.usr.r72`
  pub svar_r72: Bool,
  /// Output: `system.contract.usr.r71`
  pub svar_r71: Bool,
  /// Output: `system.contract.usr.r64`
  pub svar_r64: Bool,
  /// Output: `system.contract.usr.r63`
  pub svar_r63: Bool,
  /// Output: `system.contract.usr.r62`
  pub svar_r62: Bool,
  /// Output: `system.contract.usr.r61`
  pub svar_r61: Bool,
  /// Output: `system.contract.usr.r50`
  pub svar_r50: Bool,
  /// Output: `system.contract.usr.r42`
  pub svar_r42: Bool,
  /// Output: `system.contract.usr.r41`
  pub svar_r41: Bool,
  /// Output: `system.contract.usr.r32`
  pub svar_r32: Bool,
  /// Output: `system.contract.usr.r31`
  pub svar_r31: Bool,
  /// Output: `system.res.abs_36`
  pub svar_abs_36: Bool,
  /// Output: `system.res.abs_35`
  pub svar_abs_35: Bool,
  /// Output: `system.res.abs_34`
  pub svar_abs_34: Bool,
  /// Output: `system.res.abs_33`
  pub svar_abs_33: Bool,
  /// Output: `system.res.abs_32`
  pub svar_abs_32: Bool,
  /// Output: `system.res.abs_31`
  pub svar_abs_31: Bool,
  /// Output: `system.res.abs_30`
  pub svar_abs_30: Bool,
  /// Output: `system.res.abs_29`
  pub svar_abs_29: Bool,
  /// Output: `.mode_R22_up_1`
  pub svar_mode_R22_up_1: Bool,
  /// Output: `.mode_R21_down_1`
  pub svar_mode_R21_down_1: Bool,
  /// Output: `.mode_R12_transient_4`
  pub svar_mode_R12_transient_4: Bool,
  /// Output: `.mode_R12_transient_3`
  pub svar_mode_R12_transient_3: Bool,
  /// Output: `.mode_R12_transient_2`
  pub svar_mode_R12_transient_2: Bool,
  /// Output: `.mode_R12_transient_1`
  pub svar_mode_R12_transient_1: Bool,
  /// Output: `.mode_R11_transient_4`
  pub svar_mode_R11_transient_4: Bool,
  /// Output: `.mode_R11_transient_3`
  pub svar_mode_R11_transient_3: Bool,
  /// Output: `.mode_R11_transient_2`
  pub svar_mode_R11_transient_2: Bool,
  /// Output: `.mode_R11_transient_1`
  pub svar_mode_R11_transient_1: Bool,
  /// Output: `.mode_R12_2`
  pub svar_mode_R12_2: Bool,
  /// Output: `.mode_R12_1`
  pub svar_mode_R12_1: Bool,
  /// Output: `.mode_R11_2`
  pub svar_mode_R11_2: Bool,
  /// Output: `.mode_R11_1`
  pub svar_mode_R11_1: Bool,
  /// Output: `.mode_waiting_4`
  pub svar_mode_waiting_4: Bool,
  /// Output: `.mode_waiting_3`
  pub svar_mode_waiting_3: Bool,
  /// Output: `.mode_waiting_2`
  pub svar_mode_waiting_2: Bool,
  /// Output: `.mode_waiting_1`
  pub svar_mode_waiting_1: Bool,
  /// Output: `.mode_extended_stable_1`
  pub svar_mode_extended_stable_1: Bool,
  /// Output: `.mode_retracted_stable_1`
  pub svar_mode_retracted_stable_1: Bool,
  /// Output: `.mode_closed_stable_1`
  pub svar_mode_closed_stable_1: Bool,
  /// Output: `.mode_open_stable_1`
  pub svar_mode_open_stable_1: Bool,

  /// Local: `system.res.abs_79`
  pub svar_abs_79: Bool,
  /// Local: `system.res.abs_78`
  pub svar_abs_78: Bool,
  /// Local: `system.res.abs_77`
  pub svar_abs_77: Bool,
  /// Local: `system.res.abs_76`
  pub svar_abs_76: Bool,
  /// Local: `system.res.abs_75`
  pub svar_abs_75: Bool,
  /// Local: `system.res.abs_74`
  pub svar_abs_74: Bool,
  /// Local: `system.res.abs_73`
  pub svar_abs_73: Bool,
  /// Local: `system.res.abs_72`
  pub svar_abs_72: Bool,
  /// Local: `system.res.abs_71`
  pub svar_abs_71: Bool,
  /// Local: `system.res.abs_70`
  pub svar_abs_70: Bool,
  /// Local: `system.res.abs_69`
  pub svar_abs_69: Bool,
  /// Local: `system.res.abs_68`
  pub svar_abs_68: Bool,
  /// Local: `system.res.abs_67`
  pub svar_abs_67: Bool,
  /// Local: `system.res.abs_66`
  pub svar_abs_66: Bool,
  /// Local: `system.res.abs_65`
  pub svar_abs_65: Int,
  /// Local: `system.res.abs_64`
  pub svar_abs_64: Bool,
  /// Local: `system.res.abs_63`
  pub svar_abs_63: Bool,
  /// Local, local: `system.impl.usr.door_3_open`
  pub svar_door_3_open: Bool,
  /// Local, local: `system.impl.usr.door_3_closed`
  pub svar_door_3_closed: Bool,
  /// Local, local: `system.impl.usr.gear_3_retracted`
  pub svar_gear_3_retracted: Bool,
  /// Local, local: `system.impl.usr.gear_3_extended`
  pub svar_gear_3_extended: Bool,
  /// Local, local: `system.impl.usr.door_2_open`
  pub svar_door_2_open: Bool,
  /// Local, local: `system.impl.usr.door_2_closed`
  pub svar_door_2_closed: Bool,
  /// Local, local: `system.impl.usr.gear_2_retracted`
  pub svar_gear_2_retracted: Bool,
  /// Local, local: `system.impl.usr.gear_2_extended`
  pub svar_gear_2_extended: Bool,
  /// Local, local: `system.impl.usr.door_1_open`
  pub svar_door_1_open: Bool,
  /// Local, local: `system.impl.usr.door_1_closed`
  pub svar_door_1_closed: Bool,
  /// Local, local: `system.impl.usr.gear_1_retracted`
  pub svar_gear_1_retracted: Bool,
  /// Local, local: `system.impl.usr.gear_1_extended`
  pub svar_gear_1_extended: Bool,
  /// Local: `system.res.abs_27`
  pub svar_abs_27: Bool,
  /// Local: `system.res.abs_25`
  pub svar_abs_25: Bool,
  /// Local: `system.res.abs_19`
  pub svar_abs_19: Bool,
  /// Local: `system.res.abs_18`
  pub svar_abs_18: Bool,
  /// Local: `system.res.abs_17`
  pub svar_abs_17: Int,
  /// Local: `system.res.abs_16`
  pub svar_abs_16: Bool,
  /// Local: `system.res.abs_15`
  pub svar_abs_15: Bool,
  /// Local: `system.res.abs_14`
  pub svar_abs_14: Int,
  /// Local: `system.res.abs_13`
  pub svar_abs_13: Bool,
  /// Local: `system.res.abs_12`
  pub svar_abs_12: Bool,
  /// Local: `system.res.abs_11`
  pub svar_abs_11: Bool,
  /// Local: `system.res.abs_10`
  pub svar_abs_10: Bool,
  /// Local: `system.res.abs_9`
  pub svar_abs_9: Int,
  /// Local, ghost: `system.contract.usr.extending`
  pub svar_extending: Int,
  /// Local: `system.res.abs_8`
  pub svar_abs_8: Int,
  /// Local: `system.res.abs_7`
  pub svar_abs_7: Bool,
  /// Local, ghost: `system.contract.usr.extend`
  pub svar_extend: Int,
  /// Local: `system.res.abs_6`
  pub svar_abs_6: Int,
  /// Local: `system.res.abs_5`
  pub svar_abs_5: Bool,
  /// Local, ghost: `system.contract.usr.retracting`
  pub svar_retracting: Int,
  /// Local: `system.res.abs_4`
  pub svar_abs_4: Int,
  /// Local: `system.res.abs_3`
  pub svar_abs_3: Bool,
  /// Local, ghost: `system.contract.usr.retract`
  pub svar_retract: Int,
  /// Local: `system.res.abs_2`
  pub svar_abs_2: Int,
  /// Local: `system.res.abs_1`
  pub svar_abs_1: Bool,
  /// Local: `system.res.abs_0`
  pub svar_abs_0: Bool,

  /// Call to `has_been_true_reset` (spec.lus line 268 col. 4).
  pub has_been_true_reset_16: Has_been_true_reset,
  /// Call to `count_when` (spec.lus line 267 col. 16).
  pub count_when_15: Count_when,
  /// Call to `count_when` (spec.lus line 270 col. 19).
  pub count_when_14: Count_when,
  /// Call to `has_been_true_reset` (spec.lus line 274 col. 4).
  pub has_been_true_reset_13: Has_been_true_reset,
  /// Call to `count_when` (spec.lus line 273 col. 15).
  pub count_when_12: Count_when,
  /// Call to `count_when` (spec.lus line 276 col. 18).
  pub count_when_11: Count_when,
  /// Call to `end_delay` (spec.lus line 291 col. 4).
  pub end_delay_10: End_delay,
  /// Call to `end_delay` (spec.lus line 294 col. 4).
  pub end_delay_9: End_delay,
  /// Call to `end_delay` (spec.lus line 297 col. 4).
  pub end_delay_8: End_delay,
  /// Call to `end_delay` (spec.lus line 300 col. 4).
  pub end_delay_7: End_delay,
  /// Call to `end_delay` (spec.lus line 304 col. 4).
  pub end_delay_6: End_delay,
  /// Call to `end_delay` (spec.lus line 307 col. 4).
  pub end_delay_5: End_delay,
  /// Call to `end_delay` (spec.lus line 310 col. 4).
  pub end_delay_4: End_delay,
  /// Call to `end_delay` (spec.lus line 313 col. 4).
  pub end_delay_3: End_delay,
  /// Call to `cylinder` (line 485 col. 40).
  pub cylinder_2: Cylinder,
  /// Call to `cylinder` (line 489 col. 33).
  pub cylinder_1: Cylinder,
  /// Call to `computing_module` (line 567 col. 6).
  pub computing_module_0: Computing_module,
}

impl Sys for System {
  type Input = (
    Bool, // svar_time_base (system.usr.time_base)
    Bool, // svar_handle_up (system.usr.handle_up)
    Bool, // svar_handle_down (system.usr.handle_down)
    Bool, // svar_gear_1_shock_absorber (system.usr.gear_1_shock_absorber)
    Bool, // svar_gear_2_shock_absorber (system.usr.gear_2_shock_absorber)
    Bool, // svar_gear_3_shock_absorber (system.usr.gear_3_shock_absorber)
    Bool, // svar_general_EV (system.usr.general_EV)
    Bool, // svar_extend_EV (system.usr.extend_EV)
    Bool, // svar_retract_EV (system.usr.retract_EV)
    Bool, // svar_close_EV (system.usr.close_EV)
    Bool, // svar_open_EV (system.usr.open_EV)
    Bool, // svar_door_closed (system.usr.door_closed)
    Bool, // svar_door_open (system.usr.door_open)
    Bool, // svar_gear_extended (system.usr.gear_extended)
    Bool, // svar_gear_retracted (system.usr.gear_retracted)
    Bool, // svar_gear_maneuvering (system.usr.gear_maneuvering)
    Bool, // svar_door_maneuvering (system.usr.door_maneuvering)
    Bool, // svar_pressurized (system.usr.pressurized)
    Bool, // svar_closed_ana (system.usr.closed_ana)
    Bool, // svar_anomaly (system.usr.anomaly)
  ) ;
  type Output = (
    Bool, // svar_r74 (system.contract.usr.r74)
    Bool, // svar_r73 (system.contract.usr.r73)
    Bool, // svar_r72 (system.contract.usr.r72)
    Bool, // svar_r71 (system.contract.usr.r71)
    Bool, // svar_r64 (system.contract.usr.r64)
    Bool, // svar_r63 (system.contract.usr.r63)
    Bool, // svar_r62 (system.contract.usr.r62)
    Bool, // svar_r61 (system.contract.usr.r61)
    Bool, // svar_r50 (system.contract.usr.r50)
    Bool, // svar_r42 (system.contract.usr.r42)
    Bool, // svar_r41 (system.contract.usr.r41)
    Bool, // svar_r32 (system.contract.usr.r32)
    Bool, // svar_r31 (system.contract.usr.r31)
    Bool, // svar_abs_36 (system.res.abs_36)
    Bool, // svar_abs_35 (system.res.abs_35)
    Bool, // svar_abs_34 (system.res.abs_34)
    Bool, // svar_abs_33 (system.res.abs_33)
    Bool, // svar_abs_32 (system.res.abs_32)
    Bool, // svar_abs_31 (system.res.abs_31)
    Bool, // svar_abs_30 (system.res.abs_30)
    Bool, // svar_abs_29 (system.res.abs_29)
    Bool, // svar_mode_R22_up_1 (.mode_R22_up_1)
    Bool, // svar_mode_R21_down_1 (.mode_R21_down_1)
    Bool, // svar_mode_R12_transient_4 (.mode_R12_transient_4)
    Bool, // svar_mode_R12_transient_3 (.mode_R12_transient_3)
    Bool, // svar_mode_R12_transient_2 (.mode_R12_transient_2)
    Bool, // svar_mode_R12_transient_1 (.mode_R12_transient_1)
    Bool, // svar_mode_R11_transient_4 (.mode_R11_transient_4)
    Bool, // svar_mode_R11_transient_3 (.mode_R11_transient_3)
    Bool, // svar_mode_R11_transient_2 (.mode_R11_transient_2)
    Bool, // svar_mode_R11_transient_1 (.mode_R11_transient_1)
    Bool, // svar_mode_R12_2 (.mode_R12_2)
    Bool, // svar_mode_R12_1 (.mode_R12_1)
    Bool, // svar_mode_R11_2 (.mode_R11_2)
    Bool, // svar_mode_R11_1 (.mode_R11_1)
    Bool, // svar_mode_waiting_4 (.mode_waiting_4)
    Bool, // svar_mode_waiting_3 (.mode_waiting_3)
    Bool, // svar_mode_waiting_2 (.mode_waiting_2)
    Bool, // svar_mode_waiting_1 (.mode_waiting_1)
    Bool, // svar_mode_extended_stable_1 (.mode_extended_stable_1)
    Bool, // svar_mode_retracted_stable_1 (.mode_retracted_stable_1)
    Bool, // svar_mode_closed_stable_1 (.mode_closed_stable_1)
    Bool, // svar_mode_open_stable_1 (.mode_open_stable_1)
  ) ;
  fn arity() -> usize { 20 }
  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
    match vec.len() {
      n if n == Self::arity() => {
        Ok( (
          try!( parse::bool(& vec[0]) ), 
          try!( parse::bool(& vec[1]) ), 
          try!( parse::bool(& vec[2]) ), 
          try!( parse::bool(& vec[3]) ), 
          try!( parse::bool(& vec[4]) ), 
          try!( parse::bool(& vec[5]) ), 
          try!( parse::bool(& vec[6]) ), 
          try!( parse::bool(& vec[7]) ), 
          try!( parse::bool(& vec[8]) ), 
          try!( parse::bool(& vec[9]) ), 
          try!( parse::bool(& vec[10]) ), 
          try!( parse::bool(& vec[11]) ), 
          try!( parse::bool(& vec[12]) ), 
          try!( parse::bool(& vec[13]) ), 
          try!( parse::bool(& vec[14]) ), 
          try!( parse::bool(& vec[15]) ), 
          try!( parse::bool(& vec[16]) ), 
          try!( parse::bool(& vec[17]) ), 
          try!( parse::bool(& vec[18]) ), 
          try!( parse::bool(& vec[19]) ),
        ) )
      },
      n => Err(
        format!(
          "arity mismatch, expected {} but got {}: {:?}",
          Self::arity(), n, vec
        )
        
      ),
    }
  }

  fn init(input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_time_base = input.0 ;
    let svar_handle_up = input.1 ;
    let svar_handle_down = input.2 ;
    let svar_gear_1_shock_absorber = input.3 ;
    let svar_gear_2_shock_absorber = input.4 ;
    let svar_gear_3_shock_absorber = input.5 ;
    let svar_general_EV = input.6 ;
    let svar_extend_EV = input.7 ;
    let svar_retract_EV = input.8 ;
    let svar_close_EV = input.9 ;
    let svar_open_EV = input.10 ;
    let svar_door_closed = input.11 ;
    let svar_door_open = input.12 ;
    let svar_gear_extended = input.13 ;
    let svar_gear_retracted = input.14 ;
    let svar_gear_maneuvering = input.15 ;
    let svar_door_maneuvering = input.16 ;
    let svar_pressurized = input.17 ;
    let svar_closed_ana = input.18 ;
    let svar_anomaly = input.19 ;
    
    // |===| Computing initial state.
    let svar_r31 = ((! (svar_extend_EV | svar_retract_EV)) | svar_door_open) ;
    let svar_r32 = ((! (svar_open_EV | svar_close_EV)) | (svar_gear_retracted | svar_gear_extended)) ;
    let svar_r41 = (! (svar_close_EV & svar_open_EV)) ;
    let svar_r42 = (! (svar_retract_EV & svar_extend_EV)) ;
    let svar_r50 = ((! (((svar_open_EV | svar_close_EV) | svar_extend_EV) | svar_retract_EV)) | svar_general_EV) ;
    let svar_closed_ana = true ;
    let svar_pressurized = true ;
    let svar_gear_maneuvering = (! (svar_gear_extended | svar_gear_retracted)) ;
    let svar_door_maneuvering = (! (svar_door_open | svar_door_closed)) ;
    let svar_abs_52 = (svar_gear_extended | svar_anomaly) ;
    let svar_abs_57 = ((! (svar_gear_extended & svar_door_closed)) | svar_open_EV) ;
    let svar_abs_37 = false ;
    let svar_abs_50 = (svar_door_closed | svar_anomaly) ;
    let svar_abs_26 = (! svar_handle_down) ;
    let svar_abs_61 = ((! ((! svar_gear_extended) & svar_door_open)) | svar_extend_EV) ;
    let svar_abs_54 = ((! (svar_gear_retracted & svar_door_closed)) | (! svar_general_EV)) ;
    let svar_abs_35 = true ;
    let svar_abs_1 = true ;
    let svar_abs_63 = false ;
    let svar_abs_38 = false ;
    let svar_abs_31 = (! (svar_door_closed & svar_door_open)) ;
    let svar_abs_22 = true ;
    let svar_abs_73 = ((svar_gear_1_shock_absorber | svar_gear_2_shock_absorber) | svar_gear_3_shock_absorber) ;
    let svar_abs_60 = ((! (svar_gear_extended & (! svar_door_closed))) | svar_close_EV) ;
    let svar_abs_20 = true ;
    let svar_abs_40 = false ;
    let svar_abs_68 = false ;
    let svar_abs_49 = (svar_gear_retracted | svar_anomaly) ;
    let svar_abs_34 = ((! ((! svar_gear_retracted) & (! svar_gear_extended))) | svar_door_open) ;
    let svar_abs_23 = true ;
    let svar_abs_69 = false ;
    let svar_abs_62 = ((! (svar_gear_retracted & svar_door_closed)) | svar_open_EV) ;
    let svar_abs_55 = ((! (svar_gear_retracted & (! svar_door_closed))) | svar_close_EV) ;
    let svar_abs_28 = (! svar_handle_up) ;
    let svar_abs_65 = 1 ;
    let svar_abs_9 = 5 ;
    let svar_abs_24 = (! (svar_handle_up & svar_handle_down)) ;
    let svar_abs_14 = 20 ;
    let svar_abs_59 = ((! (svar_gear_extended & svar_door_closed)) | (! svar_general_EV)) ;
    let svar_abs_48 = false ;
    let svar_abs_32 = (! (svar_gear_extended & svar_gear_retracted)) ;
    let svar_abs_44 = (! svar_open_EV) ;
    let svar_abs_33 = ((! svar_door_closed) | (svar_gear_retracted | svar_gear_extended)) ;
    let svar_abs_17 = 100 ;
    let svar_abs_56 = ((! ((! svar_gear_retracted) & svar_door_open)) | svar_retract_EV) ;
    let svar_abs_46 = (! svar_extend_EV) ;
    let svar_abs_30 = ((! svar_handle_up) | ((svar_gear_retracted | svar_gear_extended) | svar_anomaly)) ;
    let svar_abs_70 = false ;
    let svar_abs_43 = (! svar_close_EV) ;
    let svar_abs_39 = false ;
    let svar_abs_29 = ((! svar_handle_down) | ((svar_gear_retracted | svar_gear_extended) | svar_anomaly)) ;
    let svar_abs_21 = true ;
    let svar_abs_64 = false ;
    let svar_abs_45 = (! svar_retract_EV) ;
    let svar_mode_extended_stable_1 = ((! svar_abs_40) | svar_gear_extended) ;
    let svar_mode_retracted_stable_1 = ((! svar_abs_39) | svar_gear_retracted) ;
    let svar_mode_closed_stable_1 = ((! svar_abs_38) | svar_door_closed) ;
    let svar_mode_open_stable_1 = ((! svar_abs_37) | svar_door_open) ;
    let has_been_true_reset_16 = try!( Has_been_true_reset::init( (
      svar_handle_up,
      svar_handle_down,
    ) ) ) ;
    let (
      svar_abs_0,
    ) = has_been_true_reset_16.output() ;
    
    let count_when_15 = try!( Count_when::init( (
      svar_abs_0,
      svar_abs_1,
    ) ) ) ;
    let (
      svar_abs_2,
    ) = count_when_15.output() ;
    
    let has_been_true_reset_13 = try!( Has_been_true_reset::init( (
      svar_handle_down,
      svar_handle_up,
    ) ) ) ;
    let (
      svar_abs_5,
    ) = has_been_true_reset_13.output() ;
    
    let count_when_12 = try!( Count_when::init( (
      svar_abs_5,
      svar_abs_1,
    ) ) ) ;
    let (
      svar_abs_6,
    ) = count_when_12.output() ;
    
    let end_delay_10 = try!( End_delay::init( (
      svar_time_base,
      svar_open_EV,
      svar_abs_9,
    ) ) ) ;
    let (
      svar_abs_10,
    ) = end_delay_10.output() ;
    
    let end_delay_9 = try!( End_delay::init( (
      svar_time_base,
      svar_close_EV,
      svar_abs_9,
    ) ) ) ;
    let (
      svar_abs_11,
    ) = end_delay_9.output() ;
    
    let end_delay_8 = try!( End_delay::init( (
      svar_time_base,
      svar_retract_EV,
      svar_abs_9,
    ) ) ) ;
    let (
      svar_abs_12,
    ) = end_delay_8.output() ;
    
    let end_delay_7 = try!( End_delay::init( (
      svar_time_base,
      svar_extend_EV,
      svar_abs_9,
    ) ) ) ;
    let (
      svar_abs_13,
    ) = end_delay_7.output() ;
    
    let end_delay_6 = try!( End_delay::init( (
      svar_time_base,
      svar_open_EV,
      svar_abs_14,
    ) ) ) ;
    let (
      svar_abs_15,
    ) = end_delay_6.output() ;
    
    let end_delay_5 = try!( End_delay::init( (
      svar_time_base,
      svar_close_EV,
      svar_abs_14,
    ) ) ) ;
    let (
      svar_abs_16,
    ) = end_delay_5.output() ;
    
    let end_delay_4 = try!( End_delay::init( (
      svar_time_base,
      svar_retract_EV,
      svar_abs_17,
    ) ) ) ;
    let (
      svar_abs_18,
    ) = end_delay_4.output() ;
    
    let end_delay_3 = try!( End_delay::init( (
      svar_time_base,
      svar_extend_EV,
      svar_abs_17,
    ) ) ) ;
    let (
      svar_abs_19,
    ) = end_delay_3.output() ;
    
    let cylinder_2 = try!( Cylinder::init( (
      svar_time_base,
      svar_abs_63,
      svar_abs_64,
      svar_abs_1,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
    ) ) ) ;
    let (
      svar_abs_66,
      svar_abs_67,
    ) = cylinder_2.output() ;
    
    let cylinder_1 = try!( Cylinder::init( (
      svar_time_base,
      svar_abs_68,
      svar_abs_69,
      svar_abs_70,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
    ) ) ) ;
    let (
      svar_abs_71,
      svar_abs_72,
    ) = cylinder_1.output() ;
    
    let computing_module_0 = try!( Computing_module::init( (
      svar_time_base,
      svar_handle_up,
      svar_handle_down,
      svar_gear_extended,
      svar_gear_retracted,
      svar_abs_73,
      svar_door_closed,
      svar_door_open,
      svar_closed_ana,
      svar_pressurized,
    ) ) ) ;
    let (
      svar_abs_74,
      svar_abs_75,
      svar_abs_76,
      svar_abs_77,
      svar_abs_78,
      svar_abs_79,
    ) = computing_module_0.output() ;
    
    let svar_general_EV = svar_abs_74 ;
    let svar_close_EV = svar_abs_75 ;
    let svar_open_EV = svar_abs_76 ;
    let svar_retract_EV = svar_abs_77 ;
    let svar_extend_EV = svar_abs_78 ;
    let svar_anomaly = svar_abs_79 ;
    let svar_door_3_open = svar_abs_71 ;
    let svar_door_3_closed = svar_abs_72 ;
    let svar_gear_3_extended = svar_abs_66 ;
    let svar_gear_3_retracted = svar_abs_67 ;
    let svar_door_2_open = svar_abs_71 ;
    let svar_door_2_closed = svar_abs_72 ;
    let svar_gear_2_extended = svar_abs_66 ;
    let svar_gear_2_retracted = svar_abs_67 ;
    let svar_door_1_open = svar_abs_71 ;
    let svar_door_1_closed = svar_abs_72 ;
    let svar_gear_1_extended = svar_abs_66 ;
    let svar_gear_1_retracted = svar_abs_67 ;
    let svar_r74 = ((! (svar_abs_19 & (! svar_gear_extended))) | svar_anomaly) ;
    let svar_r73 = ((! (svar_abs_18 & (! svar_gear_retracted))) | svar_anomaly) ;
    let svar_r72 = ((! (svar_abs_16 & (! svar_door_closed))) | svar_anomaly) ;
    let svar_r71 = ((! (svar_abs_15 & (! svar_door_open))) | svar_anomaly) ;
    let svar_r64 = ((! (svar_abs_13 & svar_gear_retracted)) | svar_anomaly) ;
    let svar_r63 = ((! (svar_abs_12 & svar_gear_extended)) | svar_anomaly) ;
    let svar_r62 = ((! (svar_abs_11 & svar_door_open)) | svar_anomaly) ;
    let svar_r61 = ((! (svar_abs_10 & svar_door_closed)) | svar_anomaly) ;
    let svar_extend = svar_abs_6 ;
    let svar_retract = svar_abs_2 ;
    let svar_gear_extended = ((svar_gear_1_extended & svar_gear_2_extended) & svar_gear_3_extended) ;
    let svar_gear_retracted = ((svar_gear_1_retracted & svar_gear_2_retracted) & svar_gear_3_retracted) ;
    let svar_door_closed = ((svar_door_1_closed & svar_door_2_closed) & svar_door_3_closed) ;
    let svar_door_open = ((svar_door_1_open & svar_door_2_open) & svar_door_3_open) ;
    let svar_abs_42 = (svar_extend == 0) ;
    let svar_abs_58 = (svar_extend > 0) ;
    let svar_abs_53 = (svar_retract > 0) ;
    let svar_abs_36 = (! ((svar_retract > 0) & (svar_extend > 0))) ;
    let svar_abs_25 = ((svar_retract < 13) & (svar_retract > 0)) ;
    let svar_abs_3 = ((svar_closed_ana & svar_pressurized) & (svar_retract > 0)) ;
    let svar_abs_41 = (svar_retract == 0) ;
    let svar_abs_7 = ((svar_closed_ana & svar_pressurized) & (svar_extend > 0)) ;
    let svar_abs_47 = (svar_retract >= 13) ;
    let svar_abs_51 = (svar_extend >= 13) ;
    let svar_abs_27 = ((svar_extend < 13) & (svar_extend > 0)) ;
    let svar_mode_R22_up_1 = ((! svar_abs_53) | svar_abs_46) ;
    let svar_mode_R21_down_1 = ((! svar_abs_58) | svar_abs_45) ;
    let svar_mode_R12_transient_4 = ((! svar_abs_58) | svar_abs_62) ;
    let svar_mode_R12_transient_3 = ((! svar_abs_58) | svar_abs_61) ;
    let svar_mode_R12_transient_2 = ((! svar_abs_58) | svar_abs_60) ;
    let svar_mode_R12_transient_1 = ((! svar_abs_58) | svar_abs_59) ;
    let svar_mode_R11_transient_4 = ((! svar_abs_53) | svar_abs_57) ;
    let svar_mode_R11_transient_3 = ((! svar_abs_53) | svar_abs_56) ;
    let svar_mode_R11_transient_2 = ((! svar_abs_53) | svar_abs_55) ;
    let svar_mode_R11_transient_1 = ((! svar_abs_53) | svar_abs_54) ;
    let svar_mode_R12_2 = ((! (svar_abs_48 & svar_abs_51)) | svar_abs_50) ;
    let svar_mode_R12_1 = ((! (svar_abs_48 & svar_abs_51)) | svar_abs_52) ;
    let svar_mode_R11_2 = ((! (svar_abs_48 & svar_abs_47)) | svar_abs_50) ;
    let svar_mode_R11_1 = ((! (svar_abs_48 & svar_abs_47)) | svar_abs_49) ;
    let svar_mode_waiting_4 = ((! (svar_abs_42 & svar_abs_41)) | svar_abs_46) ;
    let svar_mode_waiting_3 = ((! (svar_abs_42 & svar_abs_41)) | svar_abs_45) ;
    let svar_mode_waiting_2 = ((! (svar_abs_42 & svar_abs_41)) | svar_abs_44) ;
    let svar_mode_waiting_1 = ((! (svar_abs_42 & svar_abs_41)) | svar_abs_43) ;
    let count_when_14 = try!( Count_when::init( (
      svar_abs_3,
      svar_abs_1,
    ) ) ) ;
    let (
      svar_abs_4,
    ) = count_when_14.output() ;
    
    let count_when_11 = try!( Count_when::init( (
      svar_abs_7,
      svar_abs_1,
    ) ) ) ;
    let (
      svar_abs_8,
    ) = count_when_11.output() ;
    
    let svar_extending = svar_abs_8 ;
    let svar_retracting = svar_abs_4 ;
    
    // |===| Checking assertions.
    
    
    // Assumption number 1 at spec.lus line 316 col. 2
    if ! svar_abs_20 {
      return Err(
        "assumption failure: spec.lus line 316 col. 2 (assumption number 1)".to_string()
      )
    } ;
    // Assumption number 2 at spec.lus line 317 col. 2
    if ! svar_abs_21 {
      return Err(
        "assumption failure: spec.lus line 317 col. 2 (assumption number 2)".to_string()
      )
    } ;
    // Assumption number 3 at spec.lus line 318 col. 2
    if ! svar_abs_22 {
      return Err(
        "assumption failure: spec.lus line 318 col. 2 (assumption number 3)".to_string()
      )
    } ;
    // Assumption number 4 at spec.lus line 319 col. 2
    if ! svar_abs_23 {
      return Err(
        "assumption failure: spec.lus line 319 col. 2 (assumption number 4)".to_string()
      )
    } ;
    // Assumption number 5 at spec.lus line 321 col. 2
    if ! svar_abs_24 {
      return Err(
        "assumption failure: spec.lus line 321 col. 2 (assumption number 5)".to_string()
      )
    } ;
    // Assumption number 6 at spec.lus line 327 col. 2
    if ! svar_time_base {
      return Err(
        "assumption failure: spec.lus line 327 col. 2 (assumption number 6)".to_string()
      )
    } ;
    // Assumption number 7 at spec.lus line 329 col. 2
    if ! svar_abs_26 {
      return Err(
        "assumption failure: spec.lus line 329 col. 2 (assumption number 7)".to_string()
      )
    } ;
    // Assumption number 8 at spec.lus line 332 col. 2
    if ! svar_abs_28 {
      return Err(
        "assumption failure: spec.lus line 332 col. 2 (assumption number 8)".to_string()
      )
    } ;// |===| Returning initial state.
    Ok( System {
      // |===| Inputs.
      svar_time_base: svar_time_base,
      svar_handle_up: svar_handle_up,
      svar_handle_down: svar_handle_down,
      svar_gear_1_shock_absorber: svar_gear_1_shock_absorber,
      svar_gear_2_shock_absorber: svar_gear_2_shock_absorber,
      svar_gear_3_shock_absorber: svar_gear_3_shock_absorber,
      svar_general_EV: svar_general_EV,
      svar_extend_EV: svar_extend_EV,
      svar_retract_EV: svar_retract_EV,
      svar_close_EV: svar_close_EV,
      svar_open_EV: svar_open_EV,
      svar_door_closed: svar_door_closed,
      svar_door_open: svar_door_open,
      svar_gear_extended: svar_gear_extended,
      svar_gear_retracted: svar_gear_retracted,
      svar_gear_maneuvering: svar_gear_maneuvering,
      svar_door_maneuvering: svar_door_maneuvering,
      svar_pressurized: svar_pressurized,
      svar_closed_ana: svar_closed_ana,
      svar_anomaly: svar_anomaly,
      
      // |===| Outputs.
      svar_r74: svar_r74,
      svar_r73: svar_r73,
      svar_r72: svar_r72,
      svar_r71: svar_r71,
      svar_r64: svar_r64,
      svar_r63: svar_r63,
      svar_r62: svar_r62,
      svar_r61: svar_r61,
      svar_r50: svar_r50,
      svar_r42: svar_r42,
      svar_r41: svar_r41,
      svar_r32: svar_r32,
      svar_r31: svar_r31,
      svar_abs_36: svar_abs_36,
      svar_abs_35: svar_abs_35,
      svar_abs_34: svar_abs_34,
      svar_abs_33: svar_abs_33,
      svar_abs_32: svar_abs_32,
      svar_abs_31: svar_abs_31,
      svar_abs_30: svar_abs_30,
      svar_abs_29: svar_abs_29,
      svar_mode_R22_up_1: svar_mode_R22_up_1,
      svar_mode_R21_down_1: svar_mode_R21_down_1,
      svar_mode_R12_transient_4: svar_mode_R12_transient_4,
      svar_mode_R12_transient_3: svar_mode_R12_transient_3,
      svar_mode_R12_transient_2: svar_mode_R12_transient_2,
      svar_mode_R12_transient_1: svar_mode_R12_transient_1,
      svar_mode_R11_transient_4: svar_mode_R11_transient_4,
      svar_mode_R11_transient_3: svar_mode_R11_transient_3,
      svar_mode_R11_transient_2: svar_mode_R11_transient_2,
      svar_mode_R11_transient_1: svar_mode_R11_transient_1,
      svar_mode_R12_2: svar_mode_R12_2,
      svar_mode_R12_1: svar_mode_R12_1,
      svar_mode_R11_2: svar_mode_R11_2,
      svar_mode_R11_1: svar_mode_R11_1,
      svar_mode_waiting_4: svar_mode_waiting_4,
      svar_mode_waiting_3: svar_mode_waiting_3,
      svar_mode_waiting_2: svar_mode_waiting_2,
      svar_mode_waiting_1: svar_mode_waiting_1,
      svar_mode_extended_stable_1: svar_mode_extended_stable_1,
      svar_mode_retracted_stable_1: svar_mode_retracted_stable_1,
      svar_mode_closed_stable_1: svar_mode_closed_stable_1,
      svar_mode_open_stable_1: svar_mode_open_stable_1,
      
      // |===| Locals.
      svar_abs_79: svar_abs_79,
      svar_abs_78: svar_abs_78,
      svar_abs_77: svar_abs_77,
      svar_abs_76: svar_abs_76,
      svar_abs_75: svar_abs_75,
      svar_abs_74: svar_abs_74,
      svar_abs_73: svar_abs_73,
      svar_abs_72: svar_abs_72,
      svar_abs_71: svar_abs_71,
      svar_abs_70: svar_abs_70,
      svar_abs_69: svar_abs_69,
      svar_abs_68: svar_abs_68,
      svar_abs_67: svar_abs_67,
      svar_abs_66: svar_abs_66,
      svar_abs_65: svar_abs_65,
      svar_abs_64: svar_abs_64,
      svar_abs_63: svar_abs_63,
      svar_door_3_open: svar_door_3_open,
      svar_door_3_closed: svar_door_3_closed,
      svar_gear_3_retracted: svar_gear_3_retracted,
      svar_gear_3_extended: svar_gear_3_extended,
      svar_door_2_open: svar_door_2_open,
      svar_door_2_closed: svar_door_2_closed,
      svar_gear_2_retracted: svar_gear_2_retracted,
      svar_gear_2_extended: svar_gear_2_extended,
      svar_door_1_open: svar_door_1_open,
      svar_door_1_closed: svar_door_1_closed,
      svar_gear_1_retracted: svar_gear_1_retracted,
      svar_gear_1_extended: svar_gear_1_extended,
      svar_abs_27: svar_abs_27,
      svar_abs_25: svar_abs_25,
      svar_abs_19: svar_abs_19,
      svar_abs_18: svar_abs_18,
      svar_abs_17: svar_abs_17,
      svar_abs_16: svar_abs_16,
      svar_abs_15: svar_abs_15,
      svar_abs_14: svar_abs_14,
      svar_abs_13: svar_abs_13,
      svar_abs_12: svar_abs_12,
      svar_abs_11: svar_abs_11,
      svar_abs_10: svar_abs_10,
      svar_abs_9: svar_abs_9,
      svar_extending: svar_extending,
      svar_abs_8: svar_abs_8,
      svar_abs_7: svar_abs_7,
      svar_extend: svar_extend,
      svar_abs_6: svar_abs_6,
      svar_abs_5: svar_abs_5,
      svar_retracting: svar_retracting,
      svar_abs_4: svar_abs_4,
      svar_abs_3: svar_abs_3,
      svar_retract: svar_retract,
      svar_abs_2: svar_abs_2,
      svar_abs_1: svar_abs_1,
      svar_abs_0: svar_abs_0,
      
      // |===| Calls.
      has_been_true_reset_16: has_been_true_reset_16,
      count_when_15: count_when_15,
      count_when_14: count_when_14,
      has_been_true_reset_13: has_been_true_reset_13,
      count_when_12: count_when_12,
      count_when_11: count_when_11,
      end_delay_10: end_delay_10,
      end_delay_9: end_delay_9,
      end_delay_8: end_delay_8,
      end_delay_7: end_delay_7,
      end_delay_6: end_delay_6,
      end_delay_5: end_delay_5,
      end_delay_4: end_delay_4,
      end_delay_3: end_delay_3,
      cylinder_2: cylinder_2,
      cylinder_1: cylinder_1,
      computing_module_0: computing_module_0,
    } )
  }

  fn next(mut self, input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_time_base = input.0 ;
    let svar_handle_up = input.1 ;
    let svar_handle_down = input.2 ;
    let svar_gear_1_shock_absorber = input.3 ;
    let svar_gear_2_shock_absorber = input.4 ;
    let svar_gear_3_shock_absorber = input.5 ;
    let svar_general_EV = input.6 ;
    let svar_extend_EV = input.7 ;
    let svar_retract_EV = input.8 ;
    let svar_close_EV = input.9 ;
    let svar_open_EV = input.10 ;
    let svar_door_closed = input.11 ;
    let svar_door_open = input.12 ;
    let svar_gear_extended = input.13 ;
    let svar_gear_retracted = input.14 ;
    let svar_gear_maneuvering = input.15 ;
    let svar_door_maneuvering = input.16 ;
    let svar_pressurized = input.17 ;
    let svar_closed_ana = input.18 ;
    let svar_anomaly = input.19 ;
    
    // |===| Computing next state.
    let svar_r31 = ((! (svar_extend_EV | svar_retract_EV)) | svar_door_open) ;
    let svar_r32 = ((! (svar_open_EV | svar_close_EV)) | (svar_gear_retracted | svar_gear_extended)) ;
    let svar_r41 = (! (svar_close_EV & svar_open_EV)) ;
    let svar_r42 = (! (svar_retract_EV & svar_extend_EV)) ;
    let svar_r50 = ((! (((svar_open_EV | svar_close_EV) | svar_extend_EV) | svar_retract_EV)) | svar_general_EV) ;
    let svar_closed_ana = true ;
    let svar_pressurized = true ;
    let svar_gear_maneuvering = (! (svar_gear_extended | svar_gear_retracted)) ;
    let svar_door_maneuvering = (! (svar_door_open | svar_door_closed)) ;
    let svar_abs_52 = (svar_gear_extended | svar_anomaly) ;
    let svar_abs_57 = ((! (svar_gear_extended & svar_door_closed)) | svar_open_EV) ;
    let svar_abs_37 = (self.svar_door_open & (! self.svar_close_EV)) ;
    let svar_abs_50 = (svar_door_closed | svar_anomaly) ;
    let svar_abs_26 = ((! self.svar_abs_25) | (! svar_handle_down)) ;
    let svar_abs_61 = ((! ((! svar_gear_extended) & svar_door_open)) | svar_extend_EV) ;
    let svar_abs_54 = ((! (svar_gear_retracted & svar_door_closed)) | (! svar_general_EV)) ;
    let svar_abs_35 = ((! self.svar_anomaly) | svar_anomaly) ;
    let svar_abs_1 = true ;
    let svar_abs_63 = self.svar_extend_EV ;
    let svar_abs_38 = (self.svar_door_closed & (! self.svar_open_EV)) ;
    let svar_abs_31 = (! (svar_door_closed & svar_door_open)) ;
    let svar_abs_22 = ((! self.svar_handle_down) | (! svar_handle_up)) ;
    let svar_abs_73 = ((svar_gear_1_shock_absorber | svar_gear_2_shock_absorber) | svar_gear_3_shock_absorber) ;
    let svar_abs_60 = ((! (svar_gear_extended & (! svar_door_closed))) | svar_close_EV) ;
    let svar_abs_20 = ((! self.svar_handle_up) | (! svar_handle_down)) ;
    let svar_abs_40 = (self.svar_gear_extended & (! self.svar_retract_EV)) ;
    let svar_abs_68 = self.svar_open_EV ;
    let svar_abs_49 = (svar_gear_retracted | svar_anomaly) ;
    let svar_abs_34 = ((! ((! svar_gear_retracted) & (! svar_gear_extended))) | svar_door_open) ;
    let svar_abs_23 = ((! (self.svar_extend > 0)) | (! svar_handle_down)) ;
    let svar_abs_69 = self.svar_close_EV ;
    let svar_abs_62 = ((! (svar_gear_retracted & svar_door_closed)) | svar_open_EV) ;
    let svar_abs_55 = ((! (svar_gear_retracted & (! svar_door_closed))) | svar_close_EV) ;
    let svar_abs_28 = ((! self.svar_abs_27) | (! svar_handle_up)) ;
    let svar_abs_65 = 1 ;
    let svar_abs_9 = 5 ;
    let svar_abs_24 = (! (svar_handle_up & svar_handle_down)) ;
    let svar_abs_14 = 20 ;
    let svar_abs_59 = ((! (svar_gear_extended & svar_door_closed)) | (! svar_general_EV)) ;
    let svar_abs_48 = (! self.svar_anomaly) ;
    let svar_abs_32 = (! (svar_gear_extended & svar_gear_retracted)) ;
    let svar_abs_44 = (! svar_open_EV) ;
    let svar_abs_33 = ((! svar_door_closed) | (svar_gear_retracted | svar_gear_extended)) ;
    let svar_abs_17 = 100 ;
    let svar_abs_56 = ((! ((! svar_gear_retracted) & svar_door_open)) | svar_retract_EV) ;
    let svar_abs_46 = (! svar_extend_EV) ;
    let svar_abs_30 = ((! svar_handle_up) | ((svar_gear_retracted | svar_gear_extended) | svar_anomaly)) ;
    let svar_abs_70 = false ;
    let svar_abs_43 = (! svar_close_EV) ;
    let svar_abs_39 = (self.svar_gear_retracted & (! self.svar_extend_EV)) ;
    let svar_abs_29 = ((! svar_handle_down) | ((svar_gear_retracted | svar_gear_extended) | svar_anomaly)) ;
    let svar_abs_21 = ((! (self.svar_retract > 0)) | (! svar_handle_up)) ;
    let svar_abs_64 = self.svar_retract_EV ;
    let svar_abs_45 = (! svar_retract_EV) ;
    let svar_mode_extended_stable_1 = ((! svar_abs_40) | svar_gear_extended) ;
    let svar_mode_retracted_stable_1 = ((! svar_abs_39) | svar_gear_retracted) ;
    let svar_mode_closed_stable_1 = ((! svar_abs_38) | svar_door_closed) ;
    let svar_mode_open_stable_1 = ((! svar_abs_37) | svar_door_open) ;
    let has_been_true_reset_16 = try!( self.has_been_true_reset_16.next( (
      svar_handle_up,
      svar_handle_down,
    ) ) ) ;
    let (
      svar_abs_0,
    ) = has_been_true_reset_16.output() ;
    let count_when_15 = try!( self.count_when_15.next( (
      svar_abs_0,
      svar_abs_1,
    ) ) ) ;
    let (
      svar_abs_2,
    ) = count_when_15.output() ;
    let has_been_true_reset_13 = try!( self.has_been_true_reset_13.next( (
      svar_handle_down,
      svar_handle_up,
    ) ) ) ;
    let (
      svar_abs_5,
    ) = has_been_true_reset_13.output() ;
    let count_when_12 = try!( self.count_when_12.next( (
      svar_abs_5,
      svar_abs_1,
    ) ) ) ;
    let (
      svar_abs_6,
    ) = count_when_12.output() ;
    let end_delay_10 = try!( self.end_delay_10.next( (
      svar_time_base,
      svar_open_EV,
      svar_abs_9,
    ) ) ) ;
    let (
      svar_abs_10,
    ) = end_delay_10.output() ;
    let end_delay_9 = try!( self.end_delay_9.next( (
      svar_time_base,
      svar_close_EV,
      svar_abs_9,
    ) ) ) ;
    let (
      svar_abs_11,
    ) = end_delay_9.output() ;
    let end_delay_8 = try!( self.end_delay_8.next( (
      svar_time_base,
      svar_retract_EV,
      svar_abs_9,
    ) ) ) ;
    let (
      svar_abs_12,
    ) = end_delay_8.output() ;
    let end_delay_7 = try!( self.end_delay_7.next( (
      svar_time_base,
      svar_extend_EV,
      svar_abs_9,
    ) ) ) ;
    let (
      svar_abs_13,
    ) = end_delay_7.output() ;
    let end_delay_6 = try!( self.end_delay_6.next( (
      svar_time_base,
      svar_open_EV,
      svar_abs_14,
    ) ) ) ;
    let (
      svar_abs_15,
    ) = end_delay_6.output() ;
    let end_delay_5 = try!( self.end_delay_5.next( (
      svar_time_base,
      svar_close_EV,
      svar_abs_14,
    ) ) ) ;
    let (
      svar_abs_16,
    ) = end_delay_5.output() ;
    let end_delay_4 = try!( self.end_delay_4.next( (
      svar_time_base,
      svar_retract_EV,
      svar_abs_17,
    ) ) ) ;
    let (
      svar_abs_18,
    ) = end_delay_4.output() ;
    let end_delay_3 = try!( self.end_delay_3.next( (
      svar_time_base,
      svar_extend_EV,
      svar_abs_17,
    ) ) ) ;
    let (
      svar_abs_19,
    ) = end_delay_3.output() ;
    let cylinder_2 = try!( self.cylinder_2.next( (
      svar_time_base,
      svar_abs_63,
      svar_abs_64,
      svar_abs_1,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
    ) ) ) ;
    let (
      svar_abs_66,
      svar_abs_67,
    ) = cylinder_2.output() ;
    let cylinder_1 = try!( self.cylinder_1.next( (
      svar_time_base,
      svar_abs_68,
      svar_abs_69,
      svar_abs_70,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
      svar_abs_65,
    ) ) ) ;
    let (
      svar_abs_71,
      svar_abs_72,
    ) = cylinder_1.output() ;
    let computing_module_0 = try!( self.computing_module_0.next( (
      svar_time_base,
      svar_handle_up,
      svar_handle_down,
      svar_gear_extended,
      svar_gear_retracted,
      svar_abs_73,
      svar_door_closed,
      svar_door_open,
      svar_closed_ana,
      svar_pressurized,
    ) ) ) ;
    let (
      svar_abs_74,
      svar_abs_75,
      svar_abs_76,
      svar_abs_77,
      svar_abs_78,
      svar_abs_79,
    ) = computing_module_0.output() ;
    let svar_general_EV = svar_abs_74 ;
    let svar_close_EV = svar_abs_75 ;
    let svar_open_EV = svar_abs_76 ;
    let svar_retract_EV = svar_abs_77 ;
    let svar_extend_EV = svar_abs_78 ;
    let svar_anomaly = svar_abs_79 ;
    let svar_door_3_open = svar_abs_71 ;
    let svar_door_3_closed = svar_abs_72 ;
    let svar_gear_3_extended = svar_abs_66 ;
    let svar_gear_3_retracted = svar_abs_67 ;
    let svar_door_2_open = svar_abs_71 ;
    let svar_door_2_closed = svar_abs_72 ;
    let svar_gear_2_extended = svar_abs_66 ;
    let svar_gear_2_retracted = svar_abs_67 ;
    let svar_door_1_open = svar_abs_71 ;
    let svar_door_1_closed = svar_abs_72 ;
    let svar_gear_1_extended = svar_abs_66 ;
    let svar_gear_1_retracted = svar_abs_67 ;
    let svar_r74 = ((! (svar_abs_19 & (! svar_gear_extended))) | svar_anomaly) ;
    let svar_r73 = ((! (svar_abs_18 & (! svar_gear_retracted))) | svar_anomaly) ;
    let svar_r72 = ((! (svar_abs_16 & (! svar_door_closed))) | svar_anomaly) ;
    let svar_r71 = ((! (svar_abs_15 & (! svar_door_open))) | svar_anomaly) ;
    let svar_r64 = ((! (svar_abs_13 & svar_gear_retracted)) | svar_anomaly) ;
    let svar_r63 = ((! (svar_abs_12 & svar_gear_extended)) | svar_anomaly) ;
    let svar_r62 = ((! (svar_abs_11 & svar_door_open)) | svar_anomaly) ;
    let svar_r61 = ((! (svar_abs_10 & svar_door_closed)) | svar_anomaly) ;
    let svar_extend = svar_abs_6 ;
    let svar_retract = svar_abs_2 ;
    let svar_gear_extended = ((svar_gear_1_extended & svar_gear_2_extended) & svar_gear_3_extended) ;
    let svar_gear_retracted = ((svar_gear_1_retracted & svar_gear_2_retracted) & svar_gear_3_retracted) ;
    let svar_door_closed = ((svar_door_1_closed & svar_door_2_closed) & svar_door_3_closed) ;
    let svar_door_open = ((svar_door_1_open & svar_door_2_open) & svar_door_3_open) ;
    let svar_abs_42 = (svar_extend == 0) ;
    let svar_abs_58 = (svar_extend > 0) ;
    let svar_abs_53 = (svar_retract > 0) ;
    let svar_abs_36 = (! ((svar_retract > 0) & (svar_extend > 0))) ;
    let svar_abs_25 = ((svar_retract < 13) & (svar_retract > 0)) ;
    let svar_abs_3 = ((svar_closed_ana & svar_pressurized) & (svar_retract > 0)) ;
    let svar_abs_41 = (svar_retract == 0) ;
    let svar_abs_7 = ((svar_closed_ana & svar_pressurized) & (svar_extend > 0)) ;
    let svar_abs_47 = (svar_retract >= 13) ;
    let svar_abs_51 = (svar_extend >= 13) ;
    let svar_abs_27 = ((svar_extend < 13) & (svar_extend > 0)) ;
    let svar_mode_R22_up_1 = ((! svar_abs_53) | svar_abs_46) ;
    let svar_mode_R21_down_1 = ((! svar_abs_58) | svar_abs_45) ;
    let svar_mode_R12_transient_4 = ((! svar_abs_58) | svar_abs_62) ;
    let svar_mode_R12_transient_3 = ((! svar_abs_58) | svar_abs_61) ;
    let svar_mode_R12_transient_2 = ((! svar_abs_58) | svar_abs_60) ;
    let svar_mode_R12_transient_1 = ((! svar_abs_58) | svar_abs_59) ;
    let svar_mode_R11_transient_4 = ((! svar_abs_53) | svar_abs_57) ;
    let svar_mode_R11_transient_3 = ((! svar_abs_53) | svar_abs_56) ;
    let svar_mode_R11_transient_2 = ((! svar_abs_53) | svar_abs_55) ;
    let svar_mode_R11_transient_1 = ((! svar_abs_53) | svar_abs_54) ;
    let svar_mode_R12_2 = ((! (svar_abs_48 & svar_abs_51)) | svar_abs_50) ;
    let svar_mode_R12_1 = ((! (svar_abs_48 & svar_abs_51)) | svar_abs_52) ;
    let svar_mode_R11_2 = ((! (svar_abs_48 & svar_abs_47)) | svar_abs_50) ;
    let svar_mode_R11_1 = ((! (svar_abs_48 & svar_abs_47)) | svar_abs_49) ;
    let svar_mode_waiting_4 = ((! (svar_abs_42 & svar_abs_41)) | svar_abs_46) ;
    let svar_mode_waiting_3 = ((! (svar_abs_42 & svar_abs_41)) | svar_abs_45) ;
    let svar_mode_waiting_2 = ((! (svar_abs_42 & svar_abs_41)) | svar_abs_44) ;
    let svar_mode_waiting_1 = ((! (svar_abs_42 & svar_abs_41)) | svar_abs_43) ;
    let count_when_14 = try!( self.count_when_14.next( (
      svar_abs_3,
      svar_abs_1,
    ) ) ) ;
    let (
      svar_abs_4,
    ) = count_when_14.output() ;
    let count_when_11 = try!( self.count_when_11.next( (
      svar_abs_7,
      svar_abs_1,
    ) ) ) ;
    let (
      svar_abs_8,
    ) = count_when_11.output() ;
    let svar_extending = svar_abs_8 ;
    let svar_retracting = svar_abs_4 ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    // Assumption number 1 at spec.lus line 316 col. 2
    if ! svar_abs_20 {
      return Err(
        "assumption failure: spec.lus line 316 col. 2 (assumption number 1)".to_string()
      )
    } ;
    // Assumption number 2 at spec.lus line 317 col. 2
    if ! svar_abs_21 {
      return Err(
        "assumption failure: spec.lus line 317 col. 2 (assumption number 2)".to_string()
      )
    } ;
    // Assumption number 3 at spec.lus line 318 col. 2
    if ! svar_abs_22 {
      return Err(
        "assumption failure: spec.lus line 318 col. 2 (assumption number 3)".to_string()
      )
    } ;
    // Assumption number 4 at spec.lus line 319 col. 2
    if ! svar_abs_23 {
      return Err(
        "assumption failure: spec.lus line 319 col. 2 (assumption number 4)".to_string()
      )
    } ;
    // Assumption number 5 at spec.lus line 321 col. 2
    if ! svar_abs_24 {
      return Err(
        "assumption failure: spec.lus line 321 col. 2 (assumption number 5)".to_string()
      )
    } ;
    // Assumption number 6 at spec.lus line 327 col. 2
    if ! svar_time_base {
      return Err(
        "assumption failure: spec.lus line 327 col. 2 (assumption number 6)".to_string()
      )
    } ;
    // Assumption number 7 at spec.lus line 329 col. 2
    if ! svar_abs_26 {
      return Err(
        "assumption failure: spec.lus line 329 col. 2 (assumption number 7)".to_string()
      )
    } ;
    // Assumption number 8 at spec.lus line 332 col. 2
    if ! svar_abs_28 {
      return Err(
        "assumption failure: spec.lus line 332 col. 2 (assumption number 8)".to_string()
      )
    } ;
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_time_base = svar_time_base ;
    self.svar_handle_up = svar_handle_up ;
    self.svar_handle_down = svar_handle_down ;
    self.svar_gear_1_shock_absorber = svar_gear_1_shock_absorber ;
    self.svar_gear_2_shock_absorber = svar_gear_2_shock_absorber ;
    self.svar_gear_3_shock_absorber = svar_gear_3_shock_absorber ;
    self.svar_general_EV = svar_general_EV ;
    self.svar_extend_EV = svar_extend_EV ;
    self.svar_retract_EV = svar_retract_EV ;
    self.svar_close_EV = svar_close_EV ;
    self.svar_open_EV = svar_open_EV ;
    self.svar_door_closed = svar_door_closed ;
    self.svar_door_open = svar_door_open ;
    self.svar_gear_extended = svar_gear_extended ;
    self.svar_gear_retracted = svar_gear_retracted ;
    self.svar_gear_maneuvering = svar_gear_maneuvering ;
    self.svar_door_maneuvering = svar_door_maneuvering ;
    self.svar_pressurized = svar_pressurized ;
    self.svar_closed_ana = svar_closed_ana ;
    self.svar_anomaly = svar_anomaly ;
    
    // |===| Outputs.
    self.svar_r74 = svar_r74 ;
    self.svar_r73 = svar_r73 ;
    self.svar_r72 = svar_r72 ;
    self.svar_r71 = svar_r71 ;
    self.svar_r64 = svar_r64 ;
    self.svar_r63 = svar_r63 ;
    self.svar_r62 = svar_r62 ;
    self.svar_r61 = svar_r61 ;
    self.svar_r50 = svar_r50 ;
    self.svar_r42 = svar_r42 ;
    self.svar_r41 = svar_r41 ;
    self.svar_r32 = svar_r32 ;
    self.svar_r31 = svar_r31 ;
    self.svar_abs_36 = svar_abs_36 ;
    self.svar_abs_35 = svar_abs_35 ;
    self.svar_abs_34 = svar_abs_34 ;
    self.svar_abs_33 = svar_abs_33 ;
    self.svar_abs_32 = svar_abs_32 ;
    self.svar_abs_31 = svar_abs_31 ;
    self.svar_abs_30 = svar_abs_30 ;
    self.svar_abs_29 = svar_abs_29 ;
    self.svar_mode_R22_up_1 = svar_mode_R22_up_1 ;
    self.svar_mode_R21_down_1 = svar_mode_R21_down_1 ;
    self.svar_mode_R12_transient_4 = svar_mode_R12_transient_4 ;
    self.svar_mode_R12_transient_3 = svar_mode_R12_transient_3 ;
    self.svar_mode_R12_transient_2 = svar_mode_R12_transient_2 ;
    self.svar_mode_R12_transient_1 = svar_mode_R12_transient_1 ;
    self.svar_mode_R11_transient_4 = svar_mode_R11_transient_4 ;
    self.svar_mode_R11_transient_3 = svar_mode_R11_transient_3 ;
    self.svar_mode_R11_transient_2 = svar_mode_R11_transient_2 ;
    self.svar_mode_R11_transient_1 = svar_mode_R11_transient_1 ;
    self.svar_mode_R12_2 = svar_mode_R12_2 ;
    self.svar_mode_R12_1 = svar_mode_R12_1 ;
    self.svar_mode_R11_2 = svar_mode_R11_2 ;
    self.svar_mode_R11_1 = svar_mode_R11_1 ;
    self.svar_mode_waiting_4 = svar_mode_waiting_4 ;
    self.svar_mode_waiting_3 = svar_mode_waiting_3 ;
    self.svar_mode_waiting_2 = svar_mode_waiting_2 ;
    self.svar_mode_waiting_1 = svar_mode_waiting_1 ;
    self.svar_mode_extended_stable_1 = svar_mode_extended_stable_1 ;
    self.svar_mode_retracted_stable_1 = svar_mode_retracted_stable_1 ;
    self.svar_mode_closed_stable_1 = svar_mode_closed_stable_1 ;
    self.svar_mode_open_stable_1 = svar_mode_open_stable_1 ;
    
    // |===| Locals.
    self.svar_abs_79 = svar_abs_79 ;
    self.svar_abs_78 = svar_abs_78 ;
    self.svar_abs_77 = svar_abs_77 ;
    self.svar_abs_76 = svar_abs_76 ;
    self.svar_abs_75 = svar_abs_75 ;
    self.svar_abs_74 = svar_abs_74 ;
    self.svar_abs_73 = svar_abs_73 ;
    self.svar_abs_72 = svar_abs_72 ;
    self.svar_abs_71 = svar_abs_71 ;
    self.svar_abs_70 = svar_abs_70 ;
    self.svar_abs_69 = svar_abs_69 ;
    self.svar_abs_68 = svar_abs_68 ;
    self.svar_abs_67 = svar_abs_67 ;
    self.svar_abs_66 = svar_abs_66 ;
    self.svar_abs_65 = svar_abs_65 ;
    self.svar_abs_64 = svar_abs_64 ;
    self.svar_abs_63 = svar_abs_63 ;
    self.svar_door_3_open = svar_door_3_open ;
    self.svar_door_3_closed = svar_door_3_closed ;
    self.svar_gear_3_retracted = svar_gear_3_retracted ;
    self.svar_gear_3_extended = svar_gear_3_extended ;
    self.svar_door_2_open = svar_door_2_open ;
    self.svar_door_2_closed = svar_door_2_closed ;
    self.svar_gear_2_retracted = svar_gear_2_retracted ;
    self.svar_gear_2_extended = svar_gear_2_extended ;
    self.svar_door_1_open = svar_door_1_open ;
    self.svar_door_1_closed = svar_door_1_closed ;
    self.svar_gear_1_retracted = svar_gear_1_retracted ;
    self.svar_gear_1_extended = svar_gear_1_extended ;
    self.svar_abs_27 = svar_abs_27 ;
    self.svar_abs_25 = svar_abs_25 ;
    self.svar_abs_19 = svar_abs_19 ;
    self.svar_abs_18 = svar_abs_18 ;
    self.svar_abs_17 = svar_abs_17 ;
    self.svar_abs_16 = svar_abs_16 ;
    self.svar_abs_15 = svar_abs_15 ;
    self.svar_abs_14 = svar_abs_14 ;
    self.svar_abs_13 = svar_abs_13 ;
    self.svar_abs_12 = svar_abs_12 ;
    self.svar_abs_11 = svar_abs_11 ;
    self.svar_abs_10 = svar_abs_10 ;
    self.svar_abs_9 = svar_abs_9 ;
    self.svar_extending = svar_extending ;
    self.svar_abs_8 = svar_abs_8 ;
    self.svar_abs_7 = svar_abs_7 ;
    self.svar_extend = svar_extend ;
    self.svar_abs_6 = svar_abs_6 ;
    self.svar_abs_5 = svar_abs_5 ;
    self.svar_retracting = svar_retracting ;
    self.svar_abs_4 = svar_abs_4 ;
    self.svar_abs_3 = svar_abs_3 ;
    self.svar_retract = svar_retract ;
    self.svar_abs_2 = svar_abs_2 ;
    self.svar_abs_1 = svar_abs_1 ;
    self.svar_abs_0 = svar_abs_0 ;
    
    // |===| Calls.
    self.has_been_true_reset_16 = has_been_true_reset_16 ;
    self.count_when_15 = count_when_15 ;
    self.count_when_14 = count_when_14 ;
    self.has_been_true_reset_13 = has_been_true_reset_13 ;
    self.count_when_12 = count_when_12 ;
    self.count_when_11 = count_when_11 ;
    self.end_delay_10 = end_delay_10 ;
    self.end_delay_9 = end_delay_9 ;
    self.end_delay_8 = end_delay_8 ;
    self.end_delay_7 = end_delay_7 ;
    self.end_delay_6 = end_delay_6 ;
    self.end_delay_5 = end_delay_5 ;
    self.end_delay_4 = end_delay_4 ;
    self.end_delay_3 = end_delay_3 ;
    self.cylinder_2 = cylinder_2 ;
    self.cylinder_1 = cylinder_1 ;
    self.computing_module_0 = computing_module_0 ;
    
    // |===| Return new state.
    Ok( self )
  }

  fn output(& self) -> Self::Output {(
    self.svar_r74,
    self.svar_r73,
    self.svar_r72,
    self.svar_r71,
    self.svar_r64,
    self.svar_r63,
    self.svar_r62,
    self.svar_r61,
    self.svar_r50,
    self.svar_r42,
    self.svar_r41,
    self.svar_r32,
    self.svar_r31,
    self.svar_abs_36,
    self.svar_abs_35,
    self.svar_abs_34,
    self.svar_abs_33,
    self.svar_abs_32,
    self.svar_abs_31,
    self.svar_abs_30,
    self.svar_abs_29,
    self.svar_mode_R22_up_1,
    self.svar_mode_R21_down_1,
    self.svar_mode_R12_transient_4,
    self.svar_mode_R12_transient_3,
    self.svar_mode_R12_transient_2,
    self.svar_mode_R12_transient_1,
    self.svar_mode_R11_transient_4,
    self.svar_mode_R11_transient_3,
    self.svar_mode_R11_transient_2,
    self.svar_mode_R11_transient_1,
    self.svar_mode_R12_2,
    self.svar_mode_R12_1,
    self.svar_mode_R11_2,
    self.svar_mode_R11_1,
    self.svar_mode_waiting_4,
    self.svar_mode_waiting_3,
    self.svar_mode_waiting_2,
    self.svar_mode_waiting_1,
    self.svar_mode_extended_stable_1,
    self.svar_mode_retracted_stable_1,
    self.svar_mode_closed_stable_1,
    self.svar_mode_open_stable_1,
  )}
  fn output_str(& self) -> String {
    format!(
      "{}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}",
      self.svar_r74,
      self.svar_r73,
      self.svar_r72,
      self.svar_r71,
      self.svar_r64,
      self.svar_r63,
      self.svar_r62,
      self.svar_r61,
      self.svar_r50,
      self.svar_r42,
      self.svar_r41,
      self.svar_r32,
      self.svar_r31,
      self.svar_abs_36,
      self.svar_abs_35,
      self.svar_abs_34,
      self.svar_abs_33,
      self.svar_abs_32,
      self.svar_abs_31,
      self.svar_abs_30,
      self.svar_abs_29,
      self.svar_mode_R22_up_1,
      self.svar_mode_R21_down_1,
      self.svar_mode_R12_transient_4,
      self.svar_mode_R12_transient_3,
      self.svar_mode_R12_transient_2,
      self.svar_mode_R12_transient_1,
      self.svar_mode_R11_transient_4,
      self.svar_mode_R11_transient_3,
      self.svar_mode_R11_transient_2,
      self.svar_mode_R11_transient_1,
      self.svar_mode_R12_2,
      self.svar_mode_R12_1,
      self.svar_mode_R11_2,
      self.svar_mode_R11_1,
      self.svar_mode_waiting_4,
      self.svar_mode_waiting_3,
      self.svar_mode_waiting_2,
      self.svar_mode_waiting_1,
      self.svar_mode_extended_stable_1,
      self.svar_mode_retracted_stable_1,
      self.svar_mode_closed_stable_1,
      self.svar_mode_open_stable_1
    )
  }
}

/// Stores the state for sub-node `computing_module`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `time_base` | Bool |
/// | `handle_up` | Bool |
/// | `handle_down` | Bool |
/// | `gear_extended` | Bool |
/// | `gear_retracted` | Bool |
/// | `gear_shock_absorber` | Bool |
/// | `door_closed` | Bool |
/// | `door_open` | Bool |
/// | `analogical_switch` | Bool |
/// | `circuit_pressurized` | Bool |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `general_EV` | Bool |
/// | `close_EV` | Bool |
/// | `open_EV` | Bool |
/// | `retract_EV` | Bool |
/// | `extend_EV` | Bool |
/// | `detect_anomaly` | Bool |
///
/// # Sub systems
///
/// | Lustre identifier | Struct | Inputs | Outputs | Position |
/// |:---:|:---:|:---:|:---:|:---:|
/// | `end_delay` | [End_delay](struct.End_delay.html) | `time_base`, `abs_41`, `abs_8` | `abs_65` | line 425 col. 5 |
/// | `end_delay` | [End_delay](struct.End_delay.html) | `time_base`, `general_EV`, `abs_5` | `abs_64` | line 424 col. 5 |
/// | `count_when` | [Count_when](struct.Count_when.html) | `abs_16`, `abs_13` | `abs_17` | spec.lus line 64 col. 15 |
/// | `has_been_true_reset` | [Has_been_true_reset](struct.Has_been_true_reset.html) | `handle_down`, `handle_up` | `abs_15` | spec.lus line 67 col. 4 |
/// | `count_when` | [Count_when](struct.Count_when.html) | `abs_12`, `abs_13` | `abs_14` | spec.lus line 58 col. 16 |
/// | `has_been_true_reset` | [Has_been_true_reset](struct.Has_been_true_reset.html) | `handle_up`, `handle_down` | `abs_11` | spec.lus line 61 col. 4 |
/// | `end_delay` | [End_delay](struct.End_delay.html) | `time_base`, `extend_EV`, `abs_8` | `abs_10` | spec.lus line 55 col. 4 |
/// | `end_delay` | [End_delay](struct.End_delay.html) | `time_base`, `retract_EV`, `abs_8` | `abs_9` | spec.lus line 52 col. 4 |
/// | `end_delay` | [End_delay](struct.End_delay.html) | `time_base`, `close_EV`, `abs_5` | `abs_7` | spec.lus line 49 col. 4 |
/// | `end_delay` | [End_delay](struct.End_delay.html) | `time_base`, `open_EV`, `abs_5` | `abs_6` | spec.lus line 46 col. 4 |
/// | `end_delay` | [End_delay](struct.End_delay.html) | `time_base`, `extend_EV`, `abs_0` | `abs_4` | spec.lus line 42 col. 4 |
/// | `end_delay` | [End_delay](struct.End_delay.html) | `time_base`, `retract_EV`, `abs_0` | `abs_3` | spec.lus line 39 col. 4 |
/// | `end_delay` | [End_delay](struct.End_delay.html) | `time_base`, `close_EV`, `abs_0` | `abs_2` | spec.lus line 36 col. 4 |
/// | `end_delay` | [End_delay](struct.End_delay.html) | `time_base`, `open_EV`, `abs_0` | `abs_1` | spec.lus line 33 col. 4 |
///
/// # Assertions
///
/// No assertions for this system.
///
/// # Assumptions
///
/// | State variable | Position | Number |
/// |:------:|:-----:|:-----:|
/// | `abs_18` | spec.lus line 71 col. 2 | 1 |
/// | `abs_19` | spec.lus line 72 col. 2 | 2 |
/// | `abs_20` | spec.lus line 75 col. 2 | 3 |
/// | `abs_21` | spec.lus line 76 col. 2 | 4 |
/// | `abs_22` | spec.lus line 79 col. 2 | 5 |
/// | `abs_23` | spec.lus line 82 col. 2 | 6 |
/// | `abs_24` | spec.lus line 85 col. 2 | 7 |
/// | `abs_25` | spec.lus line 88 col. 2 | 8 |
/// | `abs_26` | spec.lus line 92 col. 2 | 9 |
/// | `abs_27` | spec.lus line 93 col. 2 | 10 |
/// | `abs_28` | spec.lus line 94 col. 2 | 11 |
/// | `abs_29` | spec.lus line 95 col. 2 | 12 |
///
pub struct Computing_module {
  /// Input: `computing_module.usr.time_base`
  pub svar_time_base: Bool,
  /// Input: `computing_module.usr.handle_up`
  pub svar_handle_up: Bool,
  /// Input: `computing_module.usr.handle_down`
  pub svar_handle_down: Bool,
  /// Input: `computing_module.usr.gear_extended`
  pub svar_gear_extended: Bool,
  /// Input: `computing_module.usr.gear_retracted`
  pub svar_gear_retracted: Bool,
  /// Input: `computing_module.usr.gear_shock_absorber`
  pub svar_gear_shock_absorber: Bool,
  /// Input: `computing_module.usr.door_closed`
  pub svar_door_closed: Bool,
  /// Input: `computing_module.usr.door_open`
  pub svar_door_open: Bool,
  /// Input: `computing_module.usr.analogical_switch`
  pub svar_analogical_switch: Bool,
  /// Input: `computing_module.usr.circuit_pressurized`
  pub svar_circuit_pressurized: Bool,

  /// Output: `computing_module.usr.general_EV`
  pub svar_general_EV: Bool,
  /// Output: `computing_module.usr.close_EV`
  pub svar_close_EV: Bool,
  /// Output: `computing_module.usr.open_EV`
  pub svar_open_EV: Bool,
  /// Output: `computing_module.usr.retract_EV`
  pub svar_retract_EV: Bool,
  /// Output: `computing_module.usr.extend_EV`
  pub svar_extend_EV: Bool,
  /// Output: `computing_module.usr.detect_anomaly`
  pub svar_detect_anomaly: Bool,

  /// Local: `computing_module.res.abs_65`
  pub svar_abs_65: Bool,
  /// Local: `computing_module.res.abs_64`
  pub svar_abs_64: Bool,
  /// Local, local: `computing_module.impl.usr.anomaly_detected`
  pub svar_anomaly_detected: Bool,
  /// Local, local: `computing_module.impl.usr.gear_blocked`
  pub svar_gear_blocked: Bool,
  /// Local, local: `computing_module.impl.usr.door_blocked`
  pub svar_door_blocked: Bool,
  /// Local, local: `computing_module.impl.usr.pressure_problem`
  pub svar_pressure_problem: Bool,
  /// Local, local: `computing_module.impl.usr.retraction`
  pub svar_retraction: Bool,
  /// Local, local: `computing_module.impl.usr.outgoing`
  pub svar_outgoing: Bool,
  /// Local: `computing_module.res.abs_62`
  pub svar_abs_62: Bool,
  /// Local: `computing_module.res.abs_60`
  pub svar_abs_60: Bool,
  /// Local: `computing_module.res.abs_53`
  pub svar_abs_53: Bool,
  /// Local: `computing_module.res.abs_51`
  pub svar_abs_51: Bool,
  /// Local: `computing_module.res.abs_49`
  pub svar_abs_49: Bool,
  /// Local: `computing_module.res.abs_46`
  pub svar_abs_46: Bool,
  /// Local: `computing_module.res.abs_43`
  pub svar_abs_43: Bool,
  /// Local, ghost: `computing_module.contract.usr.extend`
  pub svar_extend: Int,
  /// Local: `computing_module.res.abs_17`
  pub svar_abs_17: Int,
  /// Local: `computing_module.res.abs_16`
  pub svar_abs_16: Bool,
  /// Local: `computing_module.res.abs_15`
  pub svar_abs_15: Bool,
  /// Local, ghost: `computing_module.contract.usr.retract`
  pub svar_retract: Int,
  /// Local: `computing_module.res.abs_14`
  pub svar_abs_14: Int,
  /// Local: `computing_module.res.abs_13`
  pub svar_abs_13: Bool,
  /// Local: `computing_module.res.abs_12`
  pub svar_abs_12: Bool,
  /// Local: `computing_module.res.abs_11`
  pub svar_abs_11: Bool,
  /// Local, ghost: `computing_module.contract.usr.r74`
  pub svar_r74: Bool,
  /// Local: `computing_module.res.abs_10`
  pub svar_abs_10: Bool,
  /// Local, ghost: `computing_module.contract.usr.r73`
  pub svar_r73: Bool,
  /// Local: `computing_module.res.abs_9`
  pub svar_abs_9: Bool,
  /// Local: `computing_module.res.abs_8`
  pub svar_abs_8: Int,
  /// Local, ghost: `computing_module.contract.usr.r72`
  pub svar_r72: Bool,
  /// Local: `computing_module.res.abs_7`
  pub svar_abs_7: Bool,
  /// Local, ghost: `computing_module.contract.usr.r71`
  pub svar_r71: Bool,
  /// Local: `computing_module.res.abs_6`
  pub svar_abs_6: Bool,
  /// Local: `computing_module.res.abs_5`
  pub svar_abs_5: Int,
  /// Local, ghost: `computing_module.contract.usr.r64`
  pub svar_r64: Bool,
  /// Local: `computing_module.res.abs_4`
  pub svar_abs_4: Bool,
  /// Local, ghost: `computing_module.contract.usr.r63`
  pub svar_r63: Bool,
  /// Local: `computing_module.res.abs_3`
  pub svar_abs_3: Bool,
  /// Local, ghost: `computing_module.contract.usr.r62`
  pub svar_r62: Bool,
  /// Local: `computing_module.res.abs_2`
  pub svar_abs_2: Bool,
  /// Local, ghost: `computing_module.contract.usr.r61`
  pub svar_r61: Bool,
  /// Local: `computing_module.res.abs_1`
  pub svar_abs_1: Bool,
  /// Local: `computing_module.res.abs_0`
  pub svar_abs_0: Int,
  /// Local, ghost: `computing_module.contract.usr.r50`
  pub svar_r50: Bool,
  /// Local, ghost: `computing_module.contract.usr.r42`
  pub svar_r42: Bool,
  /// Local, ghost: `computing_module.contract.usr.r41`
  pub svar_r41: Bool,

  /// Call to `end_delay` (spec.lus line 33 col. 4).
  pub end_delay_13: End_delay,
  /// Call to `end_delay` (spec.lus line 36 col. 4).
  pub end_delay_12: End_delay,
  /// Call to `end_delay` (spec.lus line 39 col. 4).
  pub end_delay_11: End_delay,
  /// Call to `end_delay` (spec.lus line 42 col. 4).
  pub end_delay_10: End_delay,
  /// Call to `end_delay` (spec.lus line 46 col. 4).
  pub end_delay_9: End_delay,
  /// Call to `end_delay` (spec.lus line 49 col. 4).
  pub end_delay_8: End_delay,
  /// Call to `end_delay` (spec.lus line 52 col. 4).
  pub end_delay_7: End_delay,
  /// Call to `end_delay` (spec.lus line 55 col. 4).
  pub end_delay_6: End_delay,
  /// Call to `has_been_true_reset` (spec.lus line 61 col. 4).
  pub has_been_true_reset_5: Has_been_true_reset,
  /// Call to `count_when` (spec.lus line 58 col. 16).
  pub count_when_4: Count_when,
  /// Call to `has_been_true_reset` (spec.lus line 67 col. 4).
  pub has_been_true_reset_3: Has_been_true_reset,
  /// Call to `count_when` (spec.lus line 64 col. 15).
  pub count_when_2: Count_when,
  /// Call to `end_delay` (line 424 col. 5).
  pub end_delay_1: End_delay,
  /// Call to `end_delay` (line 425 col. 5).
  pub end_delay_0: End_delay,
}

impl Sys for Computing_module {
  type Input = (
    Bool, // svar_time_base (computing_module.usr.time_base)
    Bool, // svar_handle_up (computing_module.usr.handle_up)
    Bool, // svar_handle_down (computing_module.usr.handle_down)
    Bool, // svar_gear_extended (computing_module.usr.gear_extended)
    Bool, // svar_gear_retracted (computing_module.usr.gear_retracted)
    Bool, // svar_gear_shock_absorber (computing_module.usr.gear_shock_absorber)
    Bool, // svar_door_closed (computing_module.usr.door_closed)
    Bool, // svar_door_open (computing_module.usr.door_open)
    Bool, // svar_analogical_switch (computing_module.usr.analogical_switch)
    Bool, // svar_circuit_pressurized (computing_module.usr.circuit_pressurized)
  ) ;
  type Output = (
    Bool, // svar_general_EV (computing_module.usr.general_EV)
    Bool, // svar_close_EV (computing_module.usr.close_EV)
    Bool, // svar_open_EV (computing_module.usr.open_EV)
    Bool, // svar_retract_EV (computing_module.usr.retract_EV)
    Bool, // svar_extend_EV (computing_module.usr.extend_EV)
    Bool, // svar_detect_anomaly (computing_module.usr.detect_anomaly)
  ) ;
  fn arity() -> usize { 10 }
  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
    match vec.len() {
      n if n == Self::arity() => {
        Ok( (
          try!( parse::bool(& vec[0]) ), 
          try!( parse::bool(& vec[1]) ), 
          try!( parse::bool(& vec[2]) ), 
          try!( parse::bool(& vec[3]) ), 
          try!( parse::bool(& vec[4]) ), 
          try!( parse::bool(& vec[5]) ), 
          try!( parse::bool(& vec[6]) ), 
          try!( parse::bool(& vec[7]) ), 
          try!( parse::bool(& vec[8]) ), 
          try!( parse::bool(& vec[9]) ),
        ) )
      },
      n => Err(
        format!(
          "arity mismatch, expected {} but got {}: {:?}",
          Self::arity(), n, vec
        )
        
      ),
    }
  }

  fn init(input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_time_base = input.0 ;
    let svar_handle_up = input.1 ;
    let svar_handle_down = input.2 ;
    let svar_gear_extended = input.3 ;
    let svar_gear_retracted = input.4 ;
    let svar_gear_shock_absorber = input.5 ;
    let svar_door_closed = input.6 ;
    let svar_door_open = input.7 ;
    let svar_analogical_switch = input.8 ;
    let svar_circuit_pressurized = input.9 ;
    
    // |===| Computing initial state.
    let svar_outgoing = ( if (svar_gear_extended & svar_door_closed) { false } else {( if svar_handle_down { true } else {false } ) } ) ;
    let svar_retraction = ( if (svar_gear_retracted & svar_door_closed) { false } else {( if svar_handle_up { true } else {false } ) } ) ;
    let svar_general_EV = ((svar_outgoing | svar_retraction) & svar_analogical_switch) ;
    let svar_open_EV = ((svar_general_EV & svar_circuit_pressurized) & (((svar_outgoing & svar_gear_retracted) & (! svar_door_open)) | ((svar_retraction & svar_gear_extended) & (! svar_door_open)))) ;
    let svar_extend_EV = ((((svar_general_EV & svar_circuit_pressurized) & svar_outgoing) & svar_door_open) & (! svar_gear_extended)) ;
    let svar_close_EV = ((svar_general_EV & svar_circuit_pressurized) & (((svar_outgoing & svar_gear_extended) & (! svar_door_closed)) | ((svar_retraction & svar_gear_retracted) & (! svar_door_closed)))) ;
    let svar_retract_EV = ((((svar_general_EV & svar_circuit_pressurized) & svar_retraction) & svar_door_open) & ((svar_gear_shock_absorber & (! svar_gear_retracted)) | (! svar_gear_shock_absorber))) ;
    let svar_abs_42 = (! svar_door_closed) ;
    let svar_abs_56 = true ;
    let svar_abs_54 = true ;
    let svar_abs_20 = true ;
    let svar_abs_30 = ((! (! svar_door_open)) | (! (svar_extend_EV | svar_retract_EV))) ;
    let svar_abs_24 = true ;
    let svar_abs_45 = (! svar_gear_retracted) ;
    let svar_abs_19 = (! svar_handle_up) ;
    let svar_abs_32 = ((! svar_retract_EV) | (svar_gear_retracted | (! (svar_open_EV | svar_close_EV)))) ;
    let svar_abs_13 = true ;
    let svar_abs_33 = true ;
    let svar_abs_28 = (! (svar_gear_extended & svar_gear_retracted)) ;
    let svar_abs_59 = true ;
    let svar_abs_23 = true ;
    let svar_abs_38 = (! svar_retract_EV) ;
    let svar_abs_22 = true ;
    let svar_abs_37 = (! svar_open_EV) ;
    let svar_abs_48 = (! svar_door_open) ;
    let svar_abs_39 = (! svar_extend_EV) ;
    let svar_abs_36 = (! svar_close_EV) ;
    let svar_abs_29 = ((! svar_door_closed) | (svar_gear_retracted | svar_gear_extended)) ;
    let svar_abs_21 = (! svar_handle_down) ;
    let svar_abs_61 = true ;
    let svar_abs_26 = (! (svar_handle_up & svar_handle_down)) ;
    let svar_abs_25 = true ;
    let svar_abs_0 = 5 ;
    let svar_abs_5 = 20 ;
    let svar_abs_44 = true ;
    let svar_abs_8 = 100 ;
    let svar_abs_58 = true ;
    let svar_abs_63 = true ;
    let svar_abs_27 = (! (svar_door_closed & svar_door_open)) ;
    let svar_abs_57 = (! svar_gear_extended) ;
    let svar_abs_52 = true ;
    let svar_abs_41 = (! svar_general_EV) ;
    let svar_abs_47 = true ;
    let svar_abs_50 = true ;
    let svar_abs_31 = ((! svar_extend_EV) | (svar_gear_extended | (! (svar_open_EV | svar_close_EV)))) ;
    let svar_abs_18 = true ;
    let end_delay_13 = try!( End_delay::init( (
      svar_time_base,
      svar_open_EV,
      svar_abs_0,
    ) ) ) ;
    let (
      svar_abs_1,
    ) = end_delay_13.output() ;
    
    let end_delay_12 = try!( End_delay::init( (
      svar_time_base,
      svar_close_EV,
      svar_abs_0,
    ) ) ) ;
    let (
      svar_abs_2,
    ) = end_delay_12.output() ;
    
    let end_delay_11 = try!( End_delay::init( (
      svar_time_base,
      svar_retract_EV,
      svar_abs_0,
    ) ) ) ;
    let (
      svar_abs_3,
    ) = end_delay_11.output() ;
    
    let end_delay_10 = try!( End_delay::init( (
      svar_time_base,
      svar_extend_EV,
      svar_abs_0,
    ) ) ) ;
    let (
      svar_abs_4,
    ) = end_delay_10.output() ;
    
    let end_delay_9 = try!( End_delay::init( (
      svar_time_base,
      svar_open_EV,
      svar_abs_5,
    ) ) ) ;
    let (
      svar_abs_6,
    ) = end_delay_9.output() ;
    
    let end_delay_8 = try!( End_delay::init( (
      svar_time_base,
      svar_close_EV,
      svar_abs_5,
    ) ) ) ;
    let (
      svar_abs_7,
    ) = end_delay_8.output() ;
    
    let end_delay_7 = try!( End_delay::init( (
      svar_time_base,
      svar_retract_EV,
      svar_abs_8,
    ) ) ) ;
    let (
      svar_abs_9,
    ) = end_delay_7.output() ;
    
    let end_delay_6 = try!( End_delay::init( (
      svar_time_base,
      svar_extend_EV,
      svar_abs_8,
    ) ) ) ;
    let (
      svar_abs_10,
    ) = end_delay_6.output() ;
    
    let has_been_true_reset_5 = try!( Has_been_true_reset::init( (
      svar_handle_up,
      svar_handle_down,
    ) ) ) ;
    let (
      svar_abs_11,
    ) = has_been_true_reset_5.output() ;
    
    let has_been_true_reset_3 = try!( Has_been_true_reset::init( (
      svar_handle_down,
      svar_handle_up,
    ) ) ) ;
    let (
      svar_abs_15,
    ) = has_been_true_reset_3.output() ;
    
    let end_delay_1 = try!( End_delay::init( (
      svar_time_base,
      svar_general_EV,
      svar_abs_5,
    ) ) ) ;
    let (
      svar_abs_64,
    ) = end_delay_1.output() ;
    
    let end_delay_0 = try!( End_delay::init( (
      svar_time_base,
      svar_abs_41,
      svar_abs_8,
    ) ) ) ;
    let (
      svar_abs_65,
    ) = end_delay_0.output() ;
    
    let svar_abs_12 = ((svar_analogical_switch & svar_circuit_pressurized) & svar_abs_11) ;
    let svar_abs_16 = ((svar_analogical_switch & svar_circuit_pressurized) & svar_abs_15) ;
    let svar_gear_blocked = ((((svar_abs_3 & svar_gear_extended) | (svar_abs_9 & (! svar_gear_retracted))) | (svar_abs_4 & svar_gear_retracted)) | (svar_abs_10 & (! svar_gear_extended))) ;
    let svar_door_blocked = ((((svar_abs_1 & svar_door_closed) | (svar_abs_6 & (! svar_door_open))) | (svar_abs_2 & svar_door_open)) | (svar_abs_7 & (! svar_door_closed))) ;
    let svar_pressure_problem = ((svar_abs_64 & (! svar_circuit_pressurized)) | (svar_abs_65 & svar_circuit_pressurized)) ;
    let svar_r50 = ((! (((svar_open_EV | svar_close_EV) | svar_extend_EV) | svar_retract_EV)) | svar_general_EV) ;
    let svar_r42 = (! (svar_retract_EV & svar_extend_EV)) ;
    let svar_r41 = (! (svar_close_EV & svar_open_EV)) ;
    let svar_anomaly_detected = ((svar_door_blocked | svar_gear_blocked) | svar_pressure_problem) ;
    let svar_detect_anomaly = svar_anomaly_detected ;
    let count_when_4 = try!( Count_when::init( (
      svar_abs_12,
      svar_abs_13,
    ) ) ) ;
    let (
      svar_abs_14,
    ) = count_when_4.output() ;
    
    let count_when_2 = try!( Count_when::init( (
      svar_abs_16,
      svar_abs_13,
    ) ) ) ;
    let (
      svar_abs_17,
    ) = count_when_2.output() ;
    
    let svar_extend = svar_abs_17 ;
    let svar_retract = svar_abs_14 ;
    let svar_r74 = ((! (svar_abs_10 & (! svar_gear_extended))) | svar_detect_anomaly) ;
    let svar_r73 = ((! (svar_abs_9 & (! svar_gear_retracted))) | svar_detect_anomaly) ;
    let svar_r72 = ((! (svar_abs_7 & (! svar_door_closed))) | svar_detect_anomaly) ;
    let svar_r71 = ((! (svar_abs_6 & (! svar_door_open))) | svar_detect_anomaly) ;
    let svar_r64 = ((! (svar_abs_4 & svar_gear_retracted)) | svar_detect_anomaly) ;
    let svar_r63 = ((! (svar_abs_3 & svar_gear_extended)) | svar_detect_anomaly) ;
    let svar_r62 = ((! (svar_abs_2 & svar_door_open)) | svar_detect_anomaly) ;
    let svar_r61 = ((! (svar_abs_1 & svar_door_closed)) | svar_detect_anomaly) ;
    let svar_abs_40 = (svar_retract > 0) ;
    let svar_abs_46 = ((svar_abs_42 & svar_gear_retracted) & svar_abs_40) ;
    let svar_abs_43 = ((svar_door_closed & svar_gear_retracted) & svar_abs_40) ;
    let svar_abs_35 = (svar_extend == 0) ;
    let svar_abs_34 = (svar_retract == 0) ;
    let svar_abs_49 = ((svar_door_open & svar_abs_45) & svar_abs_40) ;
    let svar_abs_51 = ((svar_abs_48 & svar_gear_extended) & svar_abs_40) ;
    let svar_abs_55 = (svar_extend > 0) ;
    let svar_abs_62 = (((svar_abs_48 & svar_gear_retracted) & svar_abs_55) | ((svar_door_open & svar_abs_57) & svar_abs_55)) ;
    let svar_abs_60 = ((svar_abs_48 & svar_gear_retracted) & svar_abs_55) ;
    let svar_abs_53 = (((svar_abs_48 & svar_gear_extended) & svar_abs_40) | ((svar_door_open & svar_abs_45) & svar_abs_40)) ;
    
    // |===| Checking assertions.
    // |===| Checking assumptions.
    
    
    
    
    // Assumption number 1 at spec.lus line 71 col. 2
    if ! svar_abs_18 {
      return Err(
        "assumption failure: spec.lus line 71 col. 2 (assumption number 1)".to_string()
      )
    } ;
    // Assumption number 2 at spec.lus line 72 col. 2
    if ! svar_abs_19 {
      return Err(
        "assumption failure: spec.lus line 72 col. 2 (assumption number 2)".to_string()
      )
    } ;
    // Assumption number 3 at spec.lus line 75 col. 2
    if ! svar_abs_20 {
      return Err(
        "assumption failure: spec.lus line 75 col. 2 (assumption number 3)".to_string()
      )
    } ;
    // Assumption number 4 at spec.lus line 76 col. 2
    if ! svar_abs_21 {
      return Err(
        "assumption failure: spec.lus line 76 col. 2 (assumption number 4)".to_string()
      )
    } ;
    // Assumption number 5 at spec.lus line 79 col. 2
    if ! svar_abs_22 {
      return Err(
        "assumption failure: spec.lus line 79 col. 2 (assumption number 5)".to_string()
      )
    } ;
    // Assumption number 6 at spec.lus line 82 col. 2
    if ! svar_abs_23 {
      return Err(
        "assumption failure: spec.lus line 82 col. 2 (assumption number 6)".to_string()
      )
    } ;
    // Assumption number 7 at spec.lus line 85 col. 2
    if ! svar_abs_24 {
      return Err(
        "assumption failure: spec.lus line 85 col. 2 (assumption number 7)".to_string()
      )
    } ;
    // Assumption number 8 at spec.lus line 88 col. 2
    if ! svar_abs_25 {
      return Err(
        "assumption failure: spec.lus line 88 col. 2 (assumption number 8)".to_string()
      )
    } ;
    // Assumption number 9 at spec.lus line 92 col. 2
    if ! svar_abs_26 {
      return Err(
        "assumption failure: spec.lus line 92 col. 2 (assumption number 9)".to_string()
      )
    } ;
    // Assumption number 10 at spec.lus line 93 col. 2
    if ! svar_abs_27 {
      return Err(
        "assumption failure: spec.lus line 93 col. 2 (assumption number 10)".to_string()
      )
    } ;
    // Assumption number 11 at spec.lus line 94 col. 2
    if ! svar_abs_28 {
      return Err(
        "assumption failure: spec.lus line 94 col. 2 (assumption number 11)".to_string()
      )
    } ;
    // Assumption number 12 at spec.lus line 95 col. 2
    if ! svar_abs_29 {
      return Err(
        "assumption failure: spec.lus line 95 col. 2 (assumption number 12)".to_string()
      )
    } ;// |===| Returning initial state.
    Ok( Computing_module {
      // |===| Inputs.
      svar_time_base: svar_time_base,
      svar_handle_up: svar_handle_up,
      svar_handle_down: svar_handle_down,
      svar_gear_extended: svar_gear_extended,
      svar_gear_retracted: svar_gear_retracted,
      svar_gear_shock_absorber: svar_gear_shock_absorber,
      svar_door_closed: svar_door_closed,
      svar_door_open: svar_door_open,
      svar_analogical_switch: svar_analogical_switch,
      svar_circuit_pressurized: svar_circuit_pressurized,
      
      // |===| Outputs.
      svar_general_EV: svar_general_EV,
      svar_close_EV: svar_close_EV,
      svar_open_EV: svar_open_EV,
      svar_retract_EV: svar_retract_EV,
      svar_extend_EV: svar_extend_EV,
      svar_detect_anomaly: svar_detect_anomaly,
      
      // |===| Locals.
      svar_abs_65: svar_abs_65,
      svar_abs_64: svar_abs_64,
      svar_anomaly_detected: svar_anomaly_detected,
      svar_gear_blocked: svar_gear_blocked,
      svar_door_blocked: svar_door_blocked,
      svar_pressure_problem: svar_pressure_problem,
      svar_retraction: svar_retraction,
      svar_outgoing: svar_outgoing,
      svar_abs_62: svar_abs_62,
      svar_abs_60: svar_abs_60,
      svar_abs_53: svar_abs_53,
      svar_abs_51: svar_abs_51,
      svar_abs_49: svar_abs_49,
      svar_abs_46: svar_abs_46,
      svar_abs_43: svar_abs_43,
      svar_extend: svar_extend,
      svar_abs_17: svar_abs_17,
      svar_abs_16: svar_abs_16,
      svar_abs_15: svar_abs_15,
      svar_retract: svar_retract,
      svar_abs_14: svar_abs_14,
      svar_abs_13: svar_abs_13,
      svar_abs_12: svar_abs_12,
      svar_abs_11: svar_abs_11,
      svar_r74: svar_r74,
      svar_abs_10: svar_abs_10,
      svar_r73: svar_r73,
      svar_abs_9: svar_abs_9,
      svar_abs_8: svar_abs_8,
      svar_r72: svar_r72,
      svar_abs_7: svar_abs_7,
      svar_r71: svar_r71,
      svar_abs_6: svar_abs_6,
      svar_abs_5: svar_abs_5,
      svar_r64: svar_r64,
      svar_abs_4: svar_abs_4,
      svar_r63: svar_r63,
      svar_abs_3: svar_abs_3,
      svar_r62: svar_r62,
      svar_abs_2: svar_abs_2,
      svar_r61: svar_r61,
      svar_abs_1: svar_abs_1,
      svar_abs_0: svar_abs_0,
      svar_r50: svar_r50,
      svar_r42: svar_r42,
      svar_r41: svar_r41,
      
      // |===| Calls.
      end_delay_13: end_delay_13,
      end_delay_12: end_delay_12,
      end_delay_11: end_delay_11,
      end_delay_10: end_delay_10,
      end_delay_9: end_delay_9,
      end_delay_8: end_delay_8,
      end_delay_7: end_delay_7,
      end_delay_6: end_delay_6,
      has_been_true_reset_5: has_been_true_reset_5,
      count_when_4: count_when_4,
      has_been_true_reset_3: has_been_true_reset_3,
      count_when_2: count_when_2,
      end_delay_1: end_delay_1,
      end_delay_0: end_delay_0,
    } )
  }

  fn next(mut self, input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_time_base = input.0 ;
    let svar_handle_up = input.1 ;
    let svar_handle_down = input.2 ;
    let svar_gear_extended = input.3 ;
    let svar_gear_retracted = input.4 ;
    let svar_gear_shock_absorber = input.5 ;
    let svar_door_closed = input.6 ;
    let svar_door_open = input.7 ;
    let svar_analogical_switch = input.8 ;
    let svar_circuit_pressurized = input.9 ;
    
    // |===| Computing next state.
    let svar_outgoing = ( if (svar_gear_extended & svar_door_closed) { false } else {( if svar_handle_down { true } else {( if svar_handle_up { false } else {self.svar_outgoing } ) } ) } ) ;
    let svar_retraction = ( if (svar_gear_retracted & svar_door_closed) { false } else {( if svar_handle_up { true } else {( if svar_handle_down { false } else {self.svar_retraction } ) } ) } ) ;
    let svar_general_EV = ((svar_outgoing | svar_retraction) & svar_analogical_switch) ;
    let svar_open_EV = ((svar_general_EV & svar_circuit_pressurized) & (((svar_outgoing & svar_gear_retracted) & (! svar_door_open)) | ((svar_retraction & svar_gear_extended) & (! svar_door_open)))) ;
    let svar_extend_EV = ((((svar_general_EV & svar_circuit_pressurized) & svar_outgoing) & svar_door_open) & (! svar_gear_extended)) ;
    let svar_close_EV = ((svar_general_EV & svar_circuit_pressurized) & (((svar_outgoing & svar_gear_extended) & (! svar_door_closed)) | ((svar_retraction & svar_gear_retracted) & (! svar_door_closed)))) ;
    let svar_retract_EV = ((((svar_general_EV & svar_circuit_pressurized) & svar_retraction) & svar_door_open) & ((svar_gear_shock_absorber & (! svar_gear_retracted)) | (! svar_gear_shock_absorber))) ;
    let svar_abs_42 = (! svar_door_closed) ;
    let svar_abs_20 = ((! self.svar_handle_down) | (! svar_handle_up)) ;
    let svar_abs_30 = ((! (! svar_door_open)) | (! (svar_extend_EV | svar_retract_EV))) ;
    let svar_abs_24 = ((! (self.svar_gear_retracted & (! self.svar_extend_EV))) | svar_gear_retracted) ;
    let svar_abs_45 = (! svar_gear_retracted) ;
    let svar_abs_19 = ((! self.svar_abs_11) | (! svar_handle_up)) ;
    let svar_abs_32 = ((! svar_retract_EV) | (svar_gear_retracted | (! (svar_open_EV | svar_close_EV)))) ;
    let svar_abs_13 = true ;
    let svar_abs_28 = (! (svar_gear_extended & svar_gear_retracted)) ;
    let svar_abs_23 = ((! (self.svar_door_closed & (! self.svar_open_EV))) | svar_door_closed) ;
    let svar_abs_38 = (! svar_retract_EV) ;
    let svar_abs_22 = ((! (self.svar_door_open & (! self.svar_close_EV))) | svar_door_open) ;
    let svar_abs_37 = (! svar_open_EV) ;
    let svar_abs_48 = (! svar_door_open) ;
    let svar_abs_39 = (! svar_extend_EV) ;
    let svar_abs_36 = (! svar_close_EV) ;
    let svar_abs_29 = ((! svar_door_closed) | (svar_gear_retracted | svar_gear_extended)) ;
    let svar_abs_21 = ((! self.svar_abs_15) | (! svar_handle_down)) ;
    let svar_abs_26 = (! (svar_handle_up & svar_handle_down)) ;
    let svar_abs_25 = ((! (self.svar_gear_extended & (! self.svar_retract_EV))) | svar_gear_extended) ;
    let svar_abs_0 = 5 ;
    let svar_abs_5 = 20 ;
    let svar_abs_44 = (! self.svar_abs_43) ;
    let svar_abs_8 = 100 ;
    let svar_abs_27 = (! (svar_door_closed & svar_door_open)) ;
    let svar_abs_57 = (! svar_gear_extended) ;
    let svar_abs_41 = (! svar_general_EV) ;
    let svar_abs_47 = (! self.svar_abs_46) ;
    let svar_abs_50 = (! self.svar_abs_49) ;
    let svar_abs_31 = ((! svar_extend_EV) | (svar_gear_extended | (! (svar_open_EV | svar_close_EV)))) ;
    let svar_abs_18 = ((! self.svar_handle_up) | (! svar_handle_down)) ;
    let end_delay_13 = try!( self.end_delay_13.next( (
      svar_time_base,
      svar_open_EV,
      svar_abs_0,
    ) ) ) ;
    let (
      svar_abs_1,
    ) = end_delay_13.output() ;
    let end_delay_12 = try!( self.end_delay_12.next( (
      svar_time_base,
      svar_close_EV,
      svar_abs_0,
    ) ) ) ;
    let (
      svar_abs_2,
    ) = end_delay_12.output() ;
    let end_delay_11 = try!( self.end_delay_11.next( (
      svar_time_base,
      svar_retract_EV,
      svar_abs_0,
    ) ) ) ;
    let (
      svar_abs_3,
    ) = end_delay_11.output() ;
    let end_delay_10 = try!( self.end_delay_10.next( (
      svar_time_base,
      svar_extend_EV,
      svar_abs_0,
    ) ) ) ;
    let (
      svar_abs_4,
    ) = end_delay_10.output() ;
    let end_delay_9 = try!( self.end_delay_9.next( (
      svar_time_base,
      svar_open_EV,
      svar_abs_5,
    ) ) ) ;
    let (
      svar_abs_6,
    ) = end_delay_9.output() ;
    let end_delay_8 = try!( self.end_delay_8.next( (
      svar_time_base,
      svar_close_EV,
      svar_abs_5,
    ) ) ) ;
    let (
      svar_abs_7,
    ) = end_delay_8.output() ;
    let end_delay_7 = try!( self.end_delay_7.next( (
      svar_time_base,
      svar_retract_EV,
      svar_abs_8,
    ) ) ) ;
    let (
      svar_abs_9,
    ) = end_delay_7.output() ;
    let end_delay_6 = try!( self.end_delay_6.next( (
      svar_time_base,
      svar_extend_EV,
      svar_abs_8,
    ) ) ) ;
    let (
      svar_abs_10,
    ) = end_delay_6.output() ;
    let has_been_true_reset_5 = try!( self.has_been_true_reset_5.next( (
      svar_handle_up,
      svar_handle_down,
    ) ) ) ;
    let (
      svar_abs_11,
    ) = has_been_true_reset_5.output() ;
    let has_been_true_reset_3 = try!( self.has_been_true_reset_3.next( (
      svar_handle_down,
      svar_handle_up,
    ) ) ) ;
    let (
      svar_abs_15,
    ) = has_been_true_reset_3.output() ;
    let end_delay_1 = try!( self.end_delay_1.next( (
      svar_time_base,
      svar_general_EV,
      svar_abs_5,
    ) ) ) ;
    let (
      svar_abs_64,
    ) = end_delay_1.output() ;
    let end_delay_0 = try!( self.end_delay_0.next( (
      svar_time_base,
      svar_abs_41,
      svar_abs_8,
    ) ) ) ;
    let (
      svar_abs_65,
    ) = end_delay_0.output() ;
    let svar_abs_12 = ((svar_analogical_switch & svar_circuit_pressurized) & svar_abs_11) ;
    let svar_abs_16 = ((svar_analogical_switch & svar_circuit_pressurized) & svar_abs_15) ;
    let svar_gear_blocked = ((((svar_abs_3 & svar_gear_extended) | (svar_abs_9 & (! svar_gear_retracted))) | (svar_abs_4 & svar_gear_retracted)) | (svar_abs_10 & (! svar_gear_extended))) ;
    let svar_door_blocked = ((((svar_abs_1 & svar_door_closed) | (svar_abs_6 & (! svar_door_open))) | (svar_abs_2 & svar_door_open)) | (svar_abs_7 & (! svar_door_closed))) ;
    let svar_pressure_problem = ((svar_abs_64 & (! svar_circuit_pressurized)) | (svar_abs_65 & svar_circuit_pressurized)) ;
    let svar_r50 = ((! (((svar_open_EV | svar_close_EV) | svar_extend_EV) | svar_retract_EV)) | svar_general_EV) ;
    let svar_r42 = (! (svar_retract_EV & svar_extend_EV)) ;
    let svar_r41 = (! (svar_close_EV & svar_open_EV)) ;
    let svar_anomaly_detected = ((svar_door_blocked | svar_gear_blocked) | svar_pressure_problem) ;
    let svar_detect_anomaly = (self.svar_detect_anomaly | svar_anomaly_detected) ;
    let svar_abs_33 = ((! self.svar_detect_anomaly) | svar_detect_anomaly) ;
    let count_when_4 = try!( self.count_when_4.next( (
      svar_abs_12,
      svar_abs_13,
    ) ) ) ;
    let (
      svar_abs_14,
    ) = count_when_4.output() ;
    let count_when_2 = try!( self.count_when_2.next( (
      svar_abs_16,
      svar_abs_13,
    ) ) ) ;
    let (
      svar_abs_17,
    ) = count_when_2.output() ;
    let svar_extend = svar_abs_17 ;
    let svar_retract = svar_abs_14 ;
    let svar_r74 = ((! (svar_abs_10 & (! svar_gear_extended))) | svar_detect_anomaly) ;
    let svar_r73 = ((! (svar_abs_9 & (! svar_gear_retracted))) | svar_detect_anomaly) ;
    let svar_r72 = ((! (svar_abs_7 & (! svar_door_closed))) | svar_detect_anomaly) ;
    let svar_r71 = ((! (svar_abs_6 & (! svar_door_open))) | svar_detect_anomaly) ;
    let svar_r64 = ((! (svar_abs_4 & svar_gear_retracted)) | svar_detect_anomaly) ;
    let svar_r63 = ((! (svar_abs_3 & svar_gear_extended)) | svar_detect_anomaly) ;
    let svar_r62 = ((! (svar_abs_2 & svar_door_open)) | svar_detect_anomaly) ;
    let svar_r61 = ((! (svar_abs_1 & svar_door_closed)) | svar_detect_anomaly) ;
    let svar_abs_40 = (svar_retract > 0) ;
    let svar_abs_46 = ((svar_abs_42 & svar_gear_retracted) & svar_abs_40) ;
    let svar_abs_43 = ((svar_door_closed & svar_gear_retracted) & svar_abs_40) ;
    let svar_abs_35 = (svar_extend == 0) ;
    let svar_abs_34 = (svar_retract == 0) ;
    let svar_abs_49 = ((svar_door_open & svar_abs_45) & svar_abs_40) ;
    let svar_abs_51 = ((svar_abs_48 & svar_gear_extended) & svar_abs_40) ;
    let svar_abs_55 = (svar_extend > 0) ;
    let svar_abs_58 = (! ((svar_abs_42 & svar_gear_extended) & svar_abs_55)) ;
    let svar_abs_63 = ((! ((svar_door_closed & svar_gear_extended) & svar_abs_55)) | (! self.svar_abs_62)) ;
    let svar_abs_52 = ((! ((svar_abs_42 & svar_gear_retracted) & svar_abs_40)) | (! self.svar_abs_51)) ;
    let svar_abs_62 = (((svar_abs_48 & svar_gear_retracted) & svar_abs_55) | ((svar_door_open & svar_abs_57) & svar_abs_55)) ;
    let svar_abs_61 = ((! ((svar_abs_42 & svar_gear_extended) & svar_abs_55)) | (! self.svar_abs_60)) ;
    let svar_abs_59 = (! ((svar_door_open & svar_abs_57) & svar_abs_55)) ;
    let svar_abs_60 = ((svar_abs_48 & svar_gear_retracted) & svar_abs_55) ;
    let svar_abs_54 = ((! ((svar_door_closed & svar_gear_retracted) & svar_abs_40)) | (! self.svar_abs_53)) ;
    let svar_abs_56 = (! ((svar_door_closed & svar_gear_extended) & svar_abs_55)) ;
    let svar_abs_53 = (((svar_abs_48 & svar_gear_extended) & svar_abs_40) | ((svar_door_open & svar_abs_45) & svar_abs_40)) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    // Assumption number 1 at spec.lus line 71 col. 2
    if ! svar_abs_18 {
      return Err(
        "assumption failure: spec.lus line 71 col. 2 (assumption number 1)".to_string()
      )
    } ;
    // Assumption number 2 at spec.lus line 72 col. 2
    if ! svar_abs_19 {
      return Err(
        "assumption failure: spec.lus line 72 col. 2 (assumption number 2)".to_string()
      )
    } ;
    // Assumption number 3 at spec.lus line 75 col. 2
    if ! svar_abs_20 {
      return Err(
        "assumption failure: spec.lus line 75 col. 2 (assumption number 3)".to_string()
      )
    } ;
    // Assumption number 4 at spec.lus line 76 col. 2
    if ! svar_abs_21 {
      return Err(
        "assumption failure: spec.lus line 76 col. 2 (assumption number 4)".to_string()
      )
    } ;
    // Assumption number 5 at spec.lus line 79 col. 2
    if ! svar_abs_22 {
      return Err(
        "assumption failure: spec.lus line 79 col. 2 (assumption number 5)".to_string()
      )
    } ;
    // Assumption number 6 at spec.lus line 82 col. 2
    if ! svar_abs_23 {
      return Err(
        "assumption failure: spec.lus line 82 col. 2 (assumption number 6)".to_string()
      )
    } ;
    // Assumption number 7 at spec.lus line 85 col. 2
    if ! svar_abs_24 {
      return Err(
        "assumption failure: spec.lus line 85 col. 2 (assumption number 7)".to_string()
      )
    } ;
    // Assumption number 8 at spec.lus line 88 col. 2
    if ! svar_abs_25 {
      return Err(
        "assumption failure: spec.lus line 88 col. 2 (assumption number 8)".to_string()
      )
    } ;
    // Assumption number 9 at spec.lus line 92 col. 2
    if ! svar_abs_26 {
      return Err(
        "assumption failure: spec.lus line 92 col. 2 (assumption number 9)".to_string()
      )
    } ;
    // Assumption number 10 at spec.lus line 93 col. 2
    if ! svar_abs_27 {
      return Err(
        "assumption failure: spec.lus line 93 col. 2 (assumption number 10)".to_string()
      )
    } ;
    // Assumption number 11 at spec.lus line 94 col. 2
    if ! svar_abs_28 {
      return Err(
        "assumption failure: spec.lus line 94 col. 2 (assumption number 11)".to_string()
      )
    } ;
    // Assumption number 12 at spec.lus line 95 col. 2
    if ! svar_abs_29 {
      return Err(
        "assumption failure: spec.lus line 95 col. 2 (assumption number 12)".to_string()
      )
    } ;
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_time_base = svar_time_base ;
    self.svar_handle_up = svar_handle_up ;
    self.svar_handle_down = svar_handle_down ;
    self.svar_gear_extended = svar_gear_extended ;
    self.svar_gear_retracted = svar_gear_retracted ;
    self.svar_gear_shock_absorber = svar_gear_shock_absorber ;
    self.svar_door_closed = svar_door_closed ;
    self.svar_door_open = svar_door_open ;
    self.svar_analogical_switch = svar_analogical_switch ;
    self.svar_circuit_pressurized = svar_circuit_pressurized ;
    
    // |===| Outputs.
    self.svar_general_EV = svar_general_EV ;
    self.svar_close_EV = svar_close_EV ;
    self.svar_open_EV = svar_open_EV ;
    self.svar_retract_EV = svar_retract_EV ;
    self.svar_extend_EV = svar_extend_EV ;
    self.svar_detect_anomaly = svar_detect_anomaly ;
    
    // |===| Locals.
    self.svar_abs_65 = svar_abs_65 ;
    self.svar_abs_64 = svar_abs_64 ;
    self.svar_anomaly_detected = svar_anomaly_detected ;
    self.svar_gear_blocked = svar_gear_blocked ;
    self.svar_door_blocked = svar_door_blocked ;
    self.svar_pressure_problem = svar_pressure_problem ;
    self.svar_retraction = svar_retraction ;
    self.svar_outgoing = svar_outgoing ;
    self.svar_abs_62 = svar_abs_62 ;
    self.svar_abs_60 = svar_abs_60 ;
    self.svar_abs_53 = svar_abs_53 ;
    self.svar_abs_51 = svar_abs_51 ;
    self.svar_abs_49 = svar_abs_49 ;
    self.svar_abs_46 = svar_abs_46 ;
    self.svar_abs_43 = svar_abs_43 ;
    self.svar_extend = svar_extend ;
    self.svar_abs_17 = svar_abs_17 ;
    self.svar_abs_16 = svar_abs_16 ;
    self.svar_abs_15 = svar_abs_15 ;
    self.svar_retract = svar_retract ;
    self.svar_abs_14 = svar_abs_14 ;
    self.svar_abs_13 = svar_abs_13 ;
    self.svar_abs_12 = svar_abs_12 ;
    self.svar_abs_11 = svar_abs_11 ;
    self.svar_r74 = svar_r74 ;
    self.svar_abs_10 = svar_abs_10 ;
    self.svar_r73 = svar_r73 ;
    self.svar_abs_9 = svar_abs_9 ;
    self.svar_abs_8 = svar_abs_8 ;
    self.svar_r72 = svar_r72 ;
    self.svar_abs_7 = svar_abs_7 ;
    self.svar_r71 = svar_r71 ;
    self.svar_abs_6 = svar_abs_6 ;
    self.svar_abs_5 = svar_abs_5 ;
    self.svar_r64 = svar_r64 ;
    self.svar_abs_4 = svar_abs_4 ;
    self.svar_r63 = svar_r63 ;
    self.svar_abs_3 = svar_abs_3 ;
    self.svar_r62 = svar_r62 ;
    self.svar_abs_2 = svar_abs_2 ;
    self.svar_r61 = svar_r61 ;
    self.svar_abs_1 = svar_abs_1 ;
    self.svar_abs_0 = svar_abs_0 ;
    self.svar_r50 = svar_r50 ;
    self.svar_r42 = svar_r42 ;
    self.svar_r41 = svar_r41 ;
    
    // |===| Calls.
    self.end_delay_13 = end_delay_13 ;
    self.end_delay_12 = end_delay_12 ;
    self.end_delay_11 = end_delay_11 ;
    self.end_delay_10 = end_delay_10 ;
    self.end_delay_9 = end_delay_9 ;
    self.end_delay_8 = end_delay_8 ;
    self.end_delay_7 = end_delay_7 ;
    self.end_delay_6 = end_delay_6 ;
    self.has_been_true_reset_5 = has_been_true_reset_5 ;
    self.count_when_4 = count_when_4 ;
    self.has_been_true_reset_3 = has_been_true_reset_3 ;
    self.count_when_2 = count_when_2 ;
    self.end_delay_1 = end_delay_1 ;
    self.end_delay_0 = end_delay_0 ;
    
    // |===| Return new state.
    Ok( self )
  }

  fn output(& self) -> Self::Output {(
    self.svar_general_EV,
    self.svar_close_EV,
    self.svar_open_EV,
    self.svar_retract_EV,
    self.svar_extend_EV,
    self.svar_detect_anomaly,
  )}
  fn output_str(& self) -> String {
    format!(
      "{}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}",
      self.svar_general_EV,
      self.svar_close_EV,
      self.svar_open_EV,
      self.svar_retract_EV,
      self.svar_extend_EV,
      self.svar_detect_anomaly
    )
  }
}

/// Stores the state for sub-node `cylinder`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `time_base` | Bool |
/// | `pressure_up` | Bool |
/// | `pressure_down` | Bool |
/// | `init_up` | Bool |
/// | `time_unlock_down` | Int |
/// | `time_down_to_up` | Int |
/// | `time_lock_up` | Int |
/// | `time_unlock_up` | Int |
/// | `time_up_to_down` | Int |
/// | `time_lock_down` | Int |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `locked_up` | Bool |
/// | `locked_down` | Bool |
///
/// # Sub systems
///
/// | Lustre identifier | Struct | Inputs | Outputs | Position |
/// |:---:|:---:|:---:|:---:|:---:|
/// | `cylinder_all_outputs` | [Cylinder_all_outputs](struct.Cylinder_all_outputs.html) | `time_base`, `pressure_up`, `pressure_down`, `init_up`, `time_unlock_down`, `time_down_to_up`, `time_lock_up`, `time_unlock_up`, `time_up_to_down`, `time_lock_down` | `abs_0`, `abs_1`, `abs_2`, `abs_3`, `abs_4`, `abs_5`, `abs_6`, `abs_7`, `abs_8` | line 251 col. 6 |
///
/// # Assertions
///
/// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
pub struct Cylinder {
  /// Input: `cylinder.usr.time_base`
  pub svar_time_base: Bool,
  /// Input: `cylinder.usr.pressure_up`
  pub svar_pressure_up: Bool,
  /// Input: `cylinder.usr.pressure_down`
  pub svar_pressure_down: Bool,
  /// Input: `cylinder.usr.init_up`
  pub svar_init_up: Bool,
  /// Input: `cylinder.usr.time_unlock_down`
  pub svar_time_unlock_down: Int,
  /// Input: `cylinder.usr.time_down_to_up`
  pub svar_time_down_to_up: Int,
  /// Input: `cylinder.usr.time_lock_up`
  pub svar_time_lock_up: Int,
  /// Input: `cylinder.usr.time_unlock_up`
  pub svar_time_unlock_up: Int,
  /// Input: `cylinder.usr.time_up_to_down`
  pub svar_time_up_to_down: Int,
  /// Input: `cylinder.usr.time_lock_down`
  pub svar_time_lock_down: Int,

  /// Output: `cylinder.usr.locked_up`
  pub svar_locked_up: Bool,
  /// Output: `cylinder.usr.locked_down`
  pub svar_locked_down: Bool,

  /// Local: `cylinder.res.abs_8`
  pub svar_abs_8: Int,
  /// Local: `cylinder.res.abs_7`
  pub svar_abs_7: Bool,
  /// Local: `cylinder.res.abs_6`
  pub svar_abs_6: Bool,
  /// Local: `cylinder.res.abs_5`
  pub svar_abs_5: Bool,
  /// Local: `cylinder.res.abs_4`
  pub svar_abs_4: Bool,
  /// Local: `cylinder.res.abs_3`
  pub svar_abs_3: Bool,
  /// Local: `cylinder.res.abs_2`
  pub svar_abs_2: Bool,
  /// Local: `cylinder.res.abs_1`
  pub svar_abs_1: Bool,
  /// Local: `cylinder.res.abs_0`
  pub svar_abs_0: Bool,
  /// Local, local: `cylinder.impl.usr.x`
  pub svar_x: Int,
  /// Local, local: `cylinder.impl.usr.locking_down`
  pub svar_locking_down: Bool,
  /// Local, local: `cylinder.impl.usr.up_to_down`
  pub svar_up_to_down: Bool,
  /// Local, local: `cylinder.impl.usr.unlocking_up`
  pub svar_unlocking_up: Bool,
  /// Local, local: `cylinder.impl.usr.locking_up`
  pub svar_locking_up: Bool,
  /// Local, local: `cylinder.impl.usr.down_to_up`
  pub svar_down_to_up: Bool,
  /// Local, local: `cylinder.impl.usr.unlocking_down`
  pub svar_unlocking_down: Bool,

  /// Call to `cylinder_all_outputs` (line 251 col. 6).
  pub cylinder_all_outputs_0: Cylinder_all_outputs,
}

impl Sys for Cylinder {
  type Input = (
    Bool, // svar_time_base (cylinder.usr.time_base)
    Bool, // svar_pressure_up (cylinder.usr.pressure_up)
    Bool, // svar_pressure_down (cylinder.usr.pressure_down)
    Bool, // svar_init_up (cylinder.usr.init_up)
    Int, // svar_time_unlock_down (cylinder.usr.time_unlock_down)
    Int, // svar_time_down_to_up (cylinder.usr.time_down_to_up)
    Int, // svar_time_lock_up (cylinder.usr.time_lock_up)
    Int, // svar_time_unlock_up (cylinder.usr.time_unlock_up)
    Int, // svar_time_up_to_down (cylinder.usr.time_up_to_down)
    Int, // svar_time_lock_down (cylinder.usr.time_lock_down)
  ) ;
  type Output = (
    Bool, // svar_locked_up (cylinder.usr.locked_up)
    Bool, // svar_locked_down (cylinder.usr.locked_down)
  ) ;
  fn arity() -> usize { 10 }
  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
    match vec.len() {
      n if n == Self::arity() => {
        Ok( (
          try!( parse::bool(& vec[0]) ), 
          try!( parse::bool(& vec[1]) ), 
          try!( parse::bool(& vec[2]) ), 
          try!( parse::bool(& vec[3]) ), 
          try!( parse::int(& vec[4]) ), 
          try!( parse::int(& vec[5]) ), 
          try!( parse::int(& vec[6]) ), 
          try!( parse::int(& vec[7]) ), 
          try!( parse::int(& vec[8]) ), 
          try!( parse::int(& vec[9]) ),
        ) )
      },
      n => Err(
        format!(
          "arity mismatch, expected {} but got {}: {:?}",
          Self::arity(), n, vec
        )
        
      ),
    }
  }

  fn init(input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_time_base = input.0 ;
    let svar_pressure_up = input.1 ;
    let svar_pressure_down = input.2 ;
    let svar_init_up = input.3 ;
    let svar_time_unlock_down = input.4 ;
    let svar_time_down_to_up = input.5 ;
    let svar_time_lock_up = input.6 ;
    let svar_time_unlock_up = input.7 ;
    let svar_time_up_to_down = input.8 ;
    let svar_time_lock_down = input.9 ;
    
    // |===| Computing initial state.
    let cylinder_all_outputs_0 = try!( Cylinder_all_outputs::init( (
      svar_time_base,
      svar_pressure_up,
      svar_pressure_down,
      svar_init_up,
      svar_time_unlock_down,
      svar_time_down_to_up,
      svar_time_lock_up,
      svar_time_unlock_up,
      svar_time_up_to_down,
      svar_time_lock_down,
    ) ) ) ;
    let (
      svar_abs_0,
      svar_abs_1,
      svar_abs_2,
      svar_abs_3,
      svar_abs_4,
      svar_abs_5,
      svar_abs_6,
      svar_abs_7,
      svar_abs_8,
    ) = cylinder_all_outputs_0.output() ;
    
    let svar_locked_up = svar_abs_0 ;
    let svar_locked_down = svar_abs_1 ;
    let svar_unlocking_down = svar_abs_2 ;
    let svar_down_to_up = svar_abs_3 ;
    let svar_locking_up = svar_abs_4 ;
    let svar_unlocking_up = svar_abs_5 ;
    let svar_up_to_down = svar_abs_6 ;
    let svar_locking_down = svar_abs_7 ;
    let svar_x = svar_abs_8 ;
    
    // |===| Checking assertions.
    // |===| Checking assumptions.
    
    
    
    
    // |===| Returning initial state.
    Ok( Cylinder {
      // |===| Inputs.
      svar_time_base: svar_time_base,
      svar_pressure_up: svar_pressure_up,
      svar_pressure_down: svar_pressure_down,
      svar_init_up: svar_init_up,
      svar_time_unlock_down: svar_time_unlock_down,
      svar_time_down_to_up: svar_time_down_to_up,
      svar_time_lock_up: svar_time_lock_up,
      svar_time_unlock_up: svar_time_unlock_up,
      svar_time_up_to_down: svar_time_up_to_down,
      svar_time_lock_down: svar_time_lock_down,
      
      // |===| Outputs.
      svar_locked_up: svar_locked_up,
      svar_locked_down: svar_locked_down,
      
      // |===| Locals.
      svar_abs_8: svar_abs_8,
      svar_abs_7: svar_abs_7,
      svar_abs_6: svar_abs_6,
      svar_abs_5: svar_abs_5,
      svar_abs_4: svar_abs_4,
      svar_abs_3: svar_abs_3,
      svar_abs_2: svar_abs_2,
      svar_abs_1: svar_abs_1,
      svar_abs_0: svar_abs_0,
      svar_x: svar_x,
      svar_locking_down: svar_locking_down,
      svar_up_to_down: svar_up_to_down,
      svar_unlocking_up: svar_unlocking_up,
      svar_locking_up: svar_locking_up,
      svar_down_to_up: svar_down_to_up,
      svar_unlocking_down: svar_unlocking_down,
      
      // |===| Calls.
      cylinder_all_outputs_0: cylinder_all_outputs_0,
    } )
  }

  fn next(mut self, input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_time_base = input.0 ;
    let svar_pressure_up = input.1 ;
    let svar_pressure_down = input.2 ;
    let svar_init_up = input.3 ;
    let svar_time_unlock_down = input.4 ;
    let svar_time_down_to_up = input.5 ;
    let svar_time_lock_up = input.6 ;
    let svar_time_unlock_up = input.7 ;
    let svar_time_up_to_down = input.8 ;
    let svar_time_lock_down = input.9 ;
    
    // |===| Computing next state.
    let cylinder_all_outputs_0 = try!( self.cylinder_all_outputs_0.next( (
      svar_time_base,
      svar_pressure_up,
      svar_pressure_down,
      svar_init_up,
      svar_time_unlock_down,
      svar_time_down_to_up,
      svar_time_lock_up,
      svar_time_unlock_up,
      svar_time_up_to_down,
      svar_time_lock_down,
    ) ) ) ;
    let (
      svar_abs_0,
      svar_abs_1,
      svar_abs_2,
      svar_abs_3,
      svar_abs_4,
      svar_abs_5,
      svar_abs_6,
      svar_abs_7,
      svar_abs_8,
    ) = cylinder_all_outputs_0.output() ;
    let svar_locked_up = svar_abs_0 ;
    let svar_locked_down = svar_abs_1 ;
    let svar_unlocking_down = svar_abs_2 ;
    let svar_down_to_up = svar_abs_3 ;
    let svar_locking_up = svar_abs_4 ;
    let svar_unlocking_up = svar_abs_5 ;
    let svar_up_to_down = svar_abs_6 ;
    let svar_locking_down = svar_abs_7 ;
    let svar_x = svar_abs_8 ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_time_base = svar_time_base ;
    self.svar_pressure_up = svar_pressure_up ;
    self.svar_pressure_down = svar_pressure_down ;
    self.svar_init_up = svar_init_up ;
    self.svar_time_unlock_down = svar_time_unlock_down ;
    self.svar_time_down_to_up = svar_time_down_to_up ;
    self.svar_time_lock_up = svar_time_lock_up ;
    self.svar_time_unlock_up = svar_time_unlock_up ;
    self.svar_time_up_to_down = svar_time_up_to_down ;
    self.svar_time_lock_down = svar_time_lock_down ;
    
    // |===| Outputs.
    self.svar_locked_up = svar_locked_up ;
    self.svar_locked_down = svar_locked_down ;
    
    // |===| Locals.
    self.svar_abs_8 = svar_abs_8 ;
    self.svar_abs_7 = svar_abs_7 ;
    self.svar_abs_6 = svar_abs_6 ;
    self.svar_abs_5 = svar_abs_5 ;
    self.svar_abs_4 = svar_abs_4 ;
    self.svar_abs_3 = svar_abs_3 ;
    self.svar_abs_2 = svar_abs_2 ;
    self.svar_abs_1 = svar_abs_1 ;
    self.svar_abs_0 = svar_abs_0 ;
    self.svar_x = svar_x ;
    self.svar_locking_down = svar_locking_down ;
    self.svar_up_to_down = svar_up_to_down ;
    self.svar_unlocking_up = svar_unlocking_up ;
    self.svar_locking_up = svar_locking_up ;
    self.svar_down_to_up = svar_down_to_up ;
    self.svar_unlocking_down = svar_unlocking_down ;
    
    // |===| Calls.
    self.cylinder_all_outputs_0 = cylinder_all_outputs_0 ;
    
    // |===| Return new state.
    Ok( self )
  }

  fn output(& self) -> Self::Output {(
    self.svar_locked_up,
    self.svar_locked_down,
  )}
  fn output_str(& self) -> String {
    format!(
      "{}, \
      {}",
      self.svar_locked_up,
      self.svar_locked_down
    )
  }
}

/// Stores the state for sub-node `end_delay`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `time_base` | Bool |
/// | `started` | Bool |
/// | `time` | Int |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `ended` | Bool |
///
/// # Sub systems
///
/// No subsystems for this system.
///
/// # Assertions
///
/// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
pub struct End_delay {
  /// Input: `end_delay.usr.time_base`
  pub svar_time_base: Bool,
  /// Input: `end_delay.usr.started`
  pub svar_started: Bool,
  /// Input: `end_delay.usr.time`
  pub svar_time: Int,

  /// Output: `end_delay.usr.ended`
  pub svar_ended: Bool,

  /// Local, local: `end_delay.impl.usr.x`
  pub svar_x: Int,

}

impl Sys for End_delay {
  type Input = (
    Bool, // svar_time_base (end_delay.usr.time_base)
    Bool, // svar_started (end_delay.usr.started)
    Int, // svar_time (end_delay.usr.time)
  ) ;
  type Output = (
    Bool, // svar_ended (end_delay.usr.ended)
  ) ;
  fn arity() -> usize { 3 }
  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
    match vec.len() {
      n if n == Self::arity() => {
        Ok( (
          try!( parse::bool(& vec[0]) ), 
          try!( parse::bool(& vec[1]) ), 
          try!( parse::int(& vec[2]) ),
        ) )
      },
      n => Err(
        format!(
          "arity mismatch, expected {} but got {}: {:?}",
          Self::arity(), n, vec
        )
        
      ),
    }
  }

  fn init(input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_time_base = input.0 ;
    let svar_started = input.1 ;
    let svar_time = input.2 ;
    
    // |===| Computing initial state.
    let svar_x = svar_time ;
    let svar_ended = (svar_started & (svar_x == 0)) ;
    
    // |===| Checking assertions.
    // |===| Checking assumptions.
    
    
    
    
    // |===| Returning initial state.
    Ok( End_delay {
      // |===| Inputs.
      svar_time_base: svar_time_base,
      svar_started: svar_started,
      svar_time: svar_time,
      
      // |===| Outputs.
      svar_ended: svar_ended,
      
      // |===| Locals.
      svar_x: svar_x,
      
      // |===| Calls.
      
    } )
  }

  fn next(mut self, input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_time_base = input.0 ;
    let svar_started = input.1 ;
    let svar_time = input.2 ;
    
    // |===| Computing next state.
    let svar_x = ( if (svar_started & (! self.svar_started)) { svar_time } else {( if ((svar_started & svar_time_base) & ((self.svar_x - 1) >= 0)) { (self.svar_x - 1) } else {self.svar_x } ) } ) ;
    let svar_ended = (svar_started & (svar_x == 0)) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_time_base = svar_time_base ;
    self.svar_started = svar_started ;
    self.svar_time = svar_time ;
    
    // |===| Outputs.
    self.svar_ended = svar_ended ;
    
    // |===| Locals.
    self.svar_x = svar_x ;
    
    // |===| Calls.
    
    
    // |===| Return new state.
    Ok( self )
  }

  fn output(& self) -> Self::Output {(
    self.svar_ended,
  )}
  fn output_str(& self) -> String {
    format!(
      "{}",
      self.svar_ended
    )
  }
}

/// Stores the state for sub-node `count_when`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `in` | Bool |
/// | `wh3n` | Bool |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `out` | Int |
///
/// # Sub systems
///
/// No subsystems for this system.
///
/// # Assertions
///
/// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
pub struct Count_when {
  /// Input: `count_when.usr.in`
  pub svar_in: Bool,
  /// Input: `count_when.usr.wh3n`
  pub svar_wh3n: Bool,

  /// Output: `count_when.usr.out`
  pub svar_out: Int,


}

impl Sys for Count_when {
  type Input = (
    Bool, // svar_in (count_when.usr.in)
    Bool, // svar_wh3n (count_when.usr.wh3n)
  ) ;
  type Output = (
    Int, // svar_out (count_when.usr.out)
  ) ;
  fn arity() -> usize { 2 }
  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
    match vec.len() {
      n if n == Self::arity() => {
        Ok( (
          try!( parse::bool(& vec[0]) ), 
          try!( parse::bool(& vec[1]) ),
        ) )
      },
      n => Err(
        format!(
          "arity mismatch, expected {} but got {}: {:?}",
          Self::arity(), n, vec
        )
        
      ),
    }
  }

  fn init(input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_in = input.0 ;
    let svar_wh3n = input.1 ;
    
    // |===| Computing initial state.
    let svar_out = ( if svar_in { (( if svar_wh3n { 1 } else {0 } ) + 0) } else {0 } ) ;
    
    // |===| Checking assertions.
    // |===| Checking assumptions.
    
    
    
    
    // |===| Returning initial state.
    Ok( Count_when {
      // |===| Inputs.
      svar_in: svar_in,
      svar_wh3n: svar_wh3n,
      
      // |===| Outputs.
      svar_out: svar_out,
      
      // |===| Locals.
      
      
      // |===| Calls.
      
    } )
  }

  fn next(mut self, input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_in = input.0 ;
    let svar_wh3n = input.1 ;
    
    // |===| Computing next state.
    let svar_out = ( if svar_in { (( if svar_wh3n { 1 } else {0 } ) + self.svar_out) } else {0 } ) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_in = svar_in ;
    self.svar_wh3n = svar_wh3n ;
    
    // |===| Outputs.
    self.svar_out = svar_out ;
    
    // |===| Locals.
    
    
    // |===| Calls.
    
    
    // |===| Return new state.
    Ok( self )
  }

  fn output(& self) -> Self::Output {(
    self.svar_out,
  )}
  fn output_str(& self) -> String {
    format!(
      "{}",
      self.svar_out
    )
  }
}

/// Stores the state for sub-node `has_been_true_reset`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `in` | Bool |
/// | `reset` | Bool |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `out` | Bool |
///
/// # Sub systems
///
/// No subsystems for this system.
///
/// # Assertions
///
/// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
pub struct Has_been_true_reset {
  /// Input: `has_been_true_reset.usr.in`
  pub svar_in: Bool,
  /// Input: `has_been_true_reset.usr.reset`
  pub svar_reset: Bool,

  /// Output: `has_been_true_reset.usr.out`
  pub svar_out: Bool,


}

impl Sys for Has_been_true_reset {
  type Input = (
    Bool, // svar_in (has_been_true_reset.usr.in)
    Bool, // svar_reset (has_been_true_reset.usr.reset)
  ) ;
  type Output = (
    Bool, // svar_out (has_been_true_reset.usr.out)
  ) ;
  fn arity() -> usize { 2 }
  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
    match vec.len() {
      n if n == Self::arity() => {
        Ok( (
          try!( parse::bool(& vec[0]) ), 
          try!( parse::bool(& vec[1]) ),
        ) )
      },
      n => Err(
        format!(
          "arity mismatch, expected {} but got {}: {:?}",
          Self::arity(), n, vec
        )
        
      ),
    }
  }

  fn init(input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_in = input.0 ;
    let svar_reset = input.1 ;
    
    // |===| Computing initial state.
    let svar_out = ( if svar_reset { false } else {svar_in } ) ;
    
    // |===| Checking assertions.
    // |===| Checking assumptions.
    
    
    
    
    // |===| Returning initial state.
    Ok( Has_been_true_reset {
      // |===| Inputs.
      svar_in: svar_in,
      svar_reset: svar_reset,
      
      // |===| Outputs.
      svar_out: svar_out,
      
      // |===| Locals.
      
      
      // |===| Calls.
      
    } )
  }

  fn next(mut self, input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_in = input.0 ;
    let svar_reset = input.1 ;
    
    // |===| Computing next state.
    let svar_out = ( if svar_reset { false } else {(svar_in | self.svar_out) } ) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_in = svar_in ;
    self.svar_reset = svar_reset ;
    
    // |===| Outputs.
    self.svar_out = svar_out ;
    
    // |===| Locals.
    
    
    // |===| Calls.
    
    
    // |===| Return new state.
    Ok( self )
  }

  fn output(& self) -> Self::Output {(
    self.svar_out,
  )}
  fn output_str(& self) -> String {
    format!(
      "{}",
      self.svar_out
    )
  }
}

/// Stores the state for sub-node `cylinder_all_outputs`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `time_base` | Bool |
/// | `pressure_up` | Bool |
/// | `pressure_down` | Bool |
/// | `i` | Bool |
/// | `time_unlock_down` | Int |
/// | `time_down_to_up` | Int |
/// | `time_lock_up` | Int |
/// | `time_unlock_up` | Int |
/// | `time_up_to_down` | Int |
/// | `time_lock_down` | Int |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `locked_up` | Bool |
/// | `locked_down` | Bool |
/// | `unlocking_down` | Bool |
/// | `down_to_up` | Bool |
/// | `locking_up` | Bool |
/// | `unlocking_up` | Bool |
/// | `up_to_down` | Bool |
/// | `locking_down` | Bool |
/// | `x` | Int |
///
/// # Sub systems
///
/// No subsystems for this system.
///
/// # Assertions
///
/// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
pub struct Cylinder_all_outputs {
  /// Input: `cylinder_all_outputs.usr.time_base`
  pub svar_time_base: Bool,
  /// Input: `cylinder_all_outputs.usr.pressure_up`
  pub svar_pressure_up: Bool,
  /// Input: `cylinder_all_outputs.usr.pressure_down`
  pub svar_pressure_down: Bool,
  /// Input: `cylinder_all_outputs.usr.i`
  pub svar_i: Bool,
  /// Input: `cylinder_all_outputs.usr.time_unlock_down`
  pub svar_time_unlock_down: Int,
  /// Input: `cylinder_all_outputs.usr.time_down_to_up`
  pub svar_time_down_to_up: Int,
  /// Input: `cylinder_all_outputs.usr.time_lock_up`
  pub svar_time_lock_up: Int,
  /// Input: `cylinder_all_outputs.usr.time_unlock_up`
  pub svar_time_unlock_up: Int,
  /// Input: `cylinder_all_outputs.usr.time_up_to_down`
  pub svar_time_up_to_down: Int,
  /// Input: `cylinder_all_outputs.usr.time_lock_down`
  pub svar_time_lock_down: Int,

  /// Output: `cylinder_all_outputs.usr.locked_up`
  pub svar_locked_up: Bool,
  /// Output: `cylinder_all_outputs.usr.locked_down`
  pub svar_locked_down: Bool,
  /// Output: `cylinder_all_outputs.usr.unlocking_down`
  pub svar_unlocking_down: Bool,
  /// Output: `cylinder_all_outputs.usr.down_to_up`
  pub svar_down_to_up: Bool,
  /// Output: `cylinder_all_outputs.usr.locking_up`
  pub svar_locking_up: Bool,
  /// Output: `cylinder_all_outputs.usr.unlocking_up`
  pub svar_unlocking_up: Bool,
  /// Output: `cylinder_all_outputs.usr.up_to_down`
  pub svar_up_to_down: Bool,
  /// Output: `cylinder_all_outputs.usr.locking_down`
  pub svar_locking_down: Bool,
  /// Output: `cylinder_all_outputs.usr.x`
  pub svar_x: Int,


}

impl Sys for Cylinder_all_outputs {
  type Input = (
    Bool, // svar_time_base (cylinder_all_outputs.usr.time_base)
    Bool, // svar_pressure_up (cylinder_all_outputs.usr.pressure_up)
    Bool, // svar_pressure_down (cylinder_all_outputs.usr.pressure_down)
    Bool, // svar_i (cylinder_all_outputs.usr.i)
    Int, // svar_time_unlock_down (cylinder_all_outputs.usr.time_unlock_down)
    Int, // svar_time_down_to_up (cylinder_all_outputs.usr.time_down_to_up)
    Int, // svar_time_lock_up (cylinder_all_outputs.usr.time_lock_up)
    Int, // svar_time_unlock_up (cylinder_all_outputs.usr.time_unlock_up)
    Int, // svar_time_up_to_down (cylinder_all_outputs.usr.time_up_to_down)
    Int, // svar_time_lock_down (cylinder_all_outputs.usr.time_lock_down)
  ) ;
  type Output = (
    Bool, // svar_locked_up (cylinder_all_outputs.usr.locked_up)
    Bool, // svar_locked_down (cylinder_all_outputs.usr.locked_down)
    Bool, // svar_unlocking_down (cylinder_all_outputs.usr.unlocking_down)
    Bool, // svar_down_to_up (cylinder_all_outputs.usr.down_to_up)
    Bool, // svar_locking_up (cylinder_all_outputs.usr.locking_up)
    Bool, // svar_unlocking_up (cylinder_all_outputs.usr.unlocking_up)
    Bool, // svar_up_to_down (cylinder_all_outputs.usr.up_to_down)
    Bool, // svar_locking_down (cylinder_all_outputs.usr.locking_down)
    Int, // svar_x (cylinder_all_outputs.usr.x)
  ) ;
  fn arity() -> usize { 10 }
  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
    match vec.len() {
      n if n == Self::arity() => {
        Ok( (
          try!( parse::bool(& vec[0]) ), 
          try!( parse::bool(& vec[1]) ), 
          try!( parse::bool(& vec[2]) ), 
          try!( parse::bool(& vec[3]) ), 
          try!( parse::int(& vec[4]) ), 
          try!( parse::int(& vec[5]) ), 
          try!( parse::int(& vec[6]) ), 
          try!( parse::int(& vec[7]) ), 
          try!( parse::int(& vec[8]) ), 
          try!( parse::int(& vec[9]) ),
        ) )
      },
      n => Err(
        format!(
          "arity mismatch, expected {} but got {}: {:?}",
          Self::arity(), n, vec
        )
        
      ),
    }
  }

  fn init(input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_time_base = input.0 ;
    let svar_pressure_up = input.1 ;
    let svar_pressure_down = input.2 ;
    let svar_i = input.3 ;
    let svar_time_unlock_down = input.4 ;
    let svar_time_down_to_up = input.5 ;
    let svar_time_lock_up = input.6 ;
    let svar_time_unlock_up = input.7 ;
    let svar_time_up_to_down = input.8 ;
    let svar_time_lock_down = input.9 ;
    
    // |===| Computing initial state.
    let svar_unlocking_down = false ;
    let svar_down_to_up = false ;
    let svar_locking_up = svar_i ;
    let svar_unlocking_up = false ;
    let svar_up_to_down = false ;
    let svar_locking_down = (! svar_i) ;
    let svar_x = 0 ;
    let svar_locked_up = (svar_locking_up & (svar_x == 0)) ;
    let svar_locked_down = (svar_locking_down & (svar_x == 0)) ;
    
    // |===| Checking assertions.
    // |===| Checking assumptions.
    
    
    
    
    // |===| Returning initial state.
    Ok( Cylinder_all_outputs {
      // |===| Inputs.
      svar_time_base: svar_time_base,
      svar_pressure_up: svar_pressure_up,
      svar_pressure_down: svar_pressure_down,
      svar_i: svar_i,
      svar_time_unlock_down: svar_time_unlock_down,
      svar_time_down_to_up: svar_time_down_to_up,
      svar_time_lock_up: svar_time_lock_up,
      svar_time_unlock_up: svar_time_unlock_up,
      svar_time_up_to_down: svar_time_up_to_down,
      svar_time_lock_down: svar_time_lock_down,
      
      // |===| Outputs.
      svar_locked_up: svar_locked_up,
      svar_locked_down: svar_locked_down,
      svar_unlocking_down: svar_unlocking_down,
      svar_down_to_up: svar_down_to_up,
      svar_locking_up: svar_locking_up,
      svar_unlocking_up: svar_unlocking_up,
      svar_up_to_down: svar_up_to_down,
      svar_locking_down: svar_locking_down,
      svar_x: svar_x,
      
      // |===| Locals.
      
      
      // |===| Calls.
      
    } )
  }

  fn next(mut self, input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_time_base = input.0 ;
    let svar_pressure_up = input.1 ;
    let svar_pressure_down = input.2 ;
    let svar_i = input.3 ;
    let svar_time_unlock_down = input.4 ;
    let svar_time_down_to_up = input.5 ;
    let svar_time_lock_up = input.6 ;
    let svar_time_unlock_up = input.7 ;
    let svar_time_up_to_down = input.8 ;
    let svar_time_lock_down = input.9 ;
    
    // |===| Computing next state.
    let svar_unlocking_down = ((self.svar_locking_down & svar_pressure_up) | ((self.svar_unlocking_down & (! svar_pressure_down)) & ((! svar_pressure_up) | (self.svar_x > 1)))) ;
    let svar_down_to_up = ((((self.svar_unlocking_down & svar_pressure_up) & (self.svar_x == 1)) | (self.svar_up_to_down & svar_pressure_up)) | ((self.svar_down_to_up & (! svar_pressure_down)) & ((! svar_pressure_up) | (self.svar_x > 1)))) ;
    let svar_locking_up = ((((self.svar_down_to_up & svar_pressure_up) & (self.svar_x == 1)) | (self.svar_unlocking_up & svar_pressure_up)) | (self.svar_locking_up & (! svar_pressure_down))) ;
    let svar_unlocking_up = ((self.svar_locking_up & svar_pressure_down) | ((self.svar_unlocking_up & (! svar_pressure_up)) & ((! svar_pressure_down) | (self.svar_x > 1)))) ;
    let svar_up_to_down = ((((self.svar_unlocking_up & svar_pressure_down) & (self.svar_x == 1)) | (self.svar_down_to_up & svar_pressure_down)) | ((self.svar_up_to_down & (! svar_pressure_up)) & ((! svar_pressure_down) | (self.svar_x > 1)))) ;
    let svar_locking_down = ((((self.svar_up_to_down & svar_pressure_down) & (self.svar_x == 1)) | (self.svar_unlocking_down & svar_pressure_down)) | (self.svar_locking_down & (! svar_pressure_up))) ;
    let svar_x = ( if (svar_unlocking_down & self.svar_locking_down) { svar_time_unlock_down } else {( if (svar_down_to_up & (self.svar_unlocking_down | self.svar_up_to_down)) { svar_time_down_to_up } else {( if (svar_locking_up & (self.svar_down_to_up | self.svar_unlocking_up)) { svar_time_lock_up } else {( if (svar_unlocking_up & self.svar_locking_up) { svar_time_unlock_up } else {( if (svar_up_to_down & (self.svar_unlocking_up | self.svar_down_to_up)) { svar_time_up_to_down } else {( if (svar_locking_down & (self.svar_up_to_down | self.svar_unlocking_down)) { svar_time_lock_down } else {( if ((((svar_pressure_down & ((svar_unlocking_up | svar_up_to_down) | svar_locking_down)) | (svar_pressure_up & ((svar_unlocking_down | svar_down_to_up) | svar_locking_up))) & (self.svar_x > 0)) & svar_time_base) { (self.svar_x - 1) } else {self.svar_x } ) } ) } ) } ) } ) } ) } ) ;
    let svar_locked_up = (svar_locking_up & (svar_x == 0)) ;
    let svar_locked_down = (svar_locking_down & (svar_x == 0)) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_time_base = svar_time_base ;
    self.svar_pressure_up = svar_pressure_up ;
    self.svar_pressure_down = svar_pressure_down ;
    self.svar_i = svar_i ;
    self.svar_time_unlock_down = svar_time_unlock_down ;
    self.svar_time_down_to_up = svar_time_down_to_up ;
    self.svar_time_lock_up = svar_time_lock_up ;
    self.svar_time_unlock_up = svar_time_unlock_up ;
    self.svar_time_up_to_down = svar_time_up_to_down ;
    self.svar_time_lock_down = svar_time_lock_down ;
    
    // |===| Outputs.
    self.svar_locked_up = svar_locked_up ;
    self.svar_locked_down = svar_locked_down ;
    self.svar_unlocking_down = svar_unlocking_down ;
    self.svar_down_to_up = svar_down_to_up ;
    self.svar_locking_up = svar_locking_up ;
    self.svar_unlocking_up = svar_unlocking_up ;
    self.svar_up_to_down = svar_up_to_down ;
    self.svar_locking_down = svar_locking_down ;
    self.svar_x = svar_x ;
    
    // |===| Locals.
    
    
    // |===| Calls.
    
    
    // |===| Return new state.
    Ok( self )
  }

  fn output(& self) -> Self::Output {(
    self.svar_locked_up,
    self.svar_locked_down,
    self.svar_unlocking_down,
    self.svar_down_to_up,
    self.svar_locking_up,
    self.svar_unlocking_up,
    self.svar_up_to_down,
    self.svar_locking_down,
    self.svar_x,
  )}
  fn output_str(& self) -> String {
    format!(
      "{}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}, \
      {}",
      self.svar_locked_up,
      self.svar_locked_down,
      self.svar_unlocking_down,
      self.svar_down_to_up,
      self.svar_locking_up,
      self.svar_unlocking_up,
      self.svar_up_to_down,
      self.svar_locking_down,
      self.svar_x
    )
  }
}



/// Types and structures for systems.
pub mod helpers {
  use std::io::{ Stdin, stdin } ;
  use std::process::exit ;

  /// Prints usage.
  pub fn help() {
    println!("") ;
    println!("\
Options:
  -h, --help
    prints this message
  --cylinder_all_outputs
    inputs:  Bool (time_base)
             Bool (pressure_up)
             Bool (pressure_down)
             Bool (i)
             Int (time_unlock_down)
             Int (time_down_to_up)
             Int (time_lock_up)
             Int (time_unlock_up)
             Int (time_up_to_down)
             Int (time_lock_down)
    outputs: Bool (locked_up)
             Bool (locked_down)
             Bool (unlocking_down)
             Bool (down_to_up)
             Bool (locking_up)
             Bool (unlocking_up)
             Bool (up_to_down)
             Bool (locking_down)
             Int (x)
  --has_been_true_reset
    inputs:  Bool (in)
             Bool (reset)
    outputs: Bool (out)
  --count_when
    inputs:  Bool (in)
             Bool (wh3n)
    outputs: Int (out)
  --end_delay
    inputs:  Bool (time_base)
             Bool (started)
             Int (time)
    outputs: Bool (ended)
  --cylinder
    inputs:  Bool (time_base)
             Bool (pressure_up)
             Bool (pressure_down)
             Bool (init_up)
             Int (time_unlock_down)
             Int (time_down_to_up)
             Int (time_lock_up)
             Int (time_unlock_up)
             Int (time_up_to_down)
             Int (time_lock_down)
    outputs: Bool (locked_up)
             Bool (locked_down)
  --computing_module
    inputs:  Bool (time_base)
             Bool (handle_up)
             Bool (handle_down)
             Bool (gear_extended)
             Bool (gear_retracted)
             Bool (gear_shock_absorber)
             Bool (door_closed)
             Bool (door_open)
             Bool (analogical_switch)
             Bool (circuit_pressurized)
    outputs: Bool (general_EV)
             Bool (close_EV)
             Bool (open_EV)
             Bool (retract_EV)
             Bool (extend_EV)
             Bool (detect_anomaly)
  --system
    inputs:  Bool (time_base)
             Bool (handle_up)
             Bool (handle_down)
             Bool (gear_1_shock_absorber)
             Bool (gear_2_shock_absorber)
             Bool (gear_3_shock_absorber)
             Bool (general_EV)
             Bool (extend_EV)
             Bool (retract_EV)
             Bool (close_EV)
             Bool (open_EV)
             Bool (door_closed)
             Bool (door_open)
             Bool (gear_extended)
             Bool (gear_retracted)
             Bool (gear_maneuvering)
             Bool (door_maneuvering)
             Bool (pressurized)
             Bool (closed_ana)
             Bool (anomaly)
    outputs: Bool (r74)
             Bool (r73)
             Bool (r72)
             Bool (r71)
             Bool (r64)
             Bool (r63)
             Bool (r62)
             Bool (r61)
             Bool (r50)
             Bool (r42)
             Bool (r41)
             Bool (r32)
             Bool (r31)
             Bool (abs_36)
             Bool (abs_35)
             Bool (abs_34)
             Bool (abs_33)
             Bool (abs_32)
             Bool (abs_31)
             Bool (abs_30)
             Bool (abs_29)
             Bool (mode_R22_up_1)
             Bool (mode_R21_down_1)
             Bool (mode_R12_transient_4)
             Bool (mode_R12_transient_3)
             Bool (mode_R12_transient_2)
             Bool (mode_R12_transient_1)
             Bool (mode_R11_transient_4)
             Bool (mode_R11_transient_3)
             Bool (mode_R11_transient_2)
             Bool (mode_R11_transient_1)
             Bool (mode_R12_2)
             Bool (mode_R12_1)
             Bool (mode_R11_2)
             Bool (mode_R11_1)
             Bool (mode_waiting_4)
             Bool (mode_waiting_3)
             Bool (mode_waiting_2)
             Bool (mode_waiting_1)
             Bool (mode_extended_stable_1)
             Bool (mode_retracted_stable_1)
             Bool (mode_closed_stable_1)
             Bool (mode_open_stable_1)
Usage:
  Inputs (outputs) are read (printed) as comma-separated values on a single
  line.
  The read-eval-print loop runs forever, write \"exit\" or \"quit\"
  to exit it cleanly.
Default system: \"system\".\
    ") ;
    println!("")
  }

  /// Prints usage, an error, and exits with status `2`.
  pub fn error<T: ::std::fmt::Display>(e: T) {
    help() ;
    println!("Error: {}", e) ;
    println!("") ;
    exit(2)
  }

  /// Handles CLA.
  pub fn clap_and_run() {
    use std::env::args ;
    let mut args = args() ;
    // Skipping first argument (name of binary).
    match args.next() {
      Some(_) => (),
      None => unreachable!(),
    } ;
    if let Some(arg) = args.next() {
      match & arg as & str {
        "-h" | "--help" => {
          help() ;
          exit(0)
        },
        "--cylinder_all_outputs" => super::Cylinder_all_outputs::run(),
        "--has_been_true_reset" => super::Has_been_true_reset::run(),
        "--count_when" => super::Count_when::run(),
        "--end_delay" => super::End_delay::run(),
        "--cylinder" => super::Cylinder::run(),
        "--computing_module" => super::Computing_module::run(),
        "--system" => super::System::run(),
        arg => error(
          format!("unexpected argument \"{}\".", arg)
        ),
      }
    } ;
    // If no argument given, run top system.
    super::System::run()
  }

  /// Alias for `i64`.
  pub type Int = i64 ;
  /// Alias for `f64`.
  pub type Real = f64 ;
  /// Alias for `bool`.
  pub type Bool = bool ;

  /// Stores an `Stdin` and a buffer to read lines.
  pub struct InputReader {
    /// Standard input.
    stdin: Stdin,
    /// String buffer.
    buff: String,
  }
  impl InputReader {
    /// Creates an input reader.
    pub fn mk() -> Self {
      InputReader {
        stdin: stdin(),
        buff: String::with_capacity(100),
      }
    }
    /// Reads comma separated inputs from standard input.
    pub fn read_inputs(& mut self) -> Result<Vec<String>, String> {
      self.buff.clear() ;
      match self.stdin.read_line(& mut self.buff) {
        Ok(_) => (),
        Err(e) => return Err(
          format!("could not read line from stdin: {}", e)
        ),
      } ;
      let chars = self.buff.trim_left().chars() ;
      let mut buff = String::new() ;
      let mut vec = vec![] ;
      for c in chars {
        match c {
          ' ' | '\t' => (),
          ',' | '\n' => {
            vec.push(buff.clone()) ;
            buff.clear()
          },
          _ => buff.push(c),
        }
      } ;
      if vec.len() > 1 {
        match vec[0].trim() {
          "exit" | "quit" => exit(0),
          _ => ()
        }
      } ;
      Ok(vec)
    }
  }

  /// Trait all systems must implement.
  pub trait Sys: Sized {
    /// Type of inputs.
    type Input ;
    /// Type of outputs.
    type Output ;
    /// Number of inputs expected.
    fn arity() -> usize ;
    /// Parses a vector of inputs.
    fn input_of(Vec<String>) -> Result<Self::Input, String> ;
    /// Initial state of the system.
    fn init(Self::Input) -> Result<Self, String> ;
    /// Computes the next step.
    fn next(self, Self::Input) -> Result<Self, String> ;
    /// Reads inputs from standard input, computes initial state, prints output.
    fn read_init(reader: & mut InputReader) -> Result<Self, String> {
      match Self::input_of( try!(reader.read_inputs()) ) {
        Ok(inputs) => {
          let init = try!( Self::init(inputs) ) ;
          println!("{}", init.output_str()) ;
          Ok(init)
        },
        Err(s) => Err(s),
      }
    }
    /// Reads inputs from standard input, computes next step, prints output.
    fn read_next(self, reader: & mut InputReader) -> Result<Self, String> {
      match Self::input_of( try!(reader.read_inputs()) ) {
        Ok(inputs) => {
          let next = try!( self.next(inputs) ) ;
          println!("{}", next.output_str()) ;
          Ok(next)
        },
        Err(s) => Err(s),
      }
    }
    /// Output of the system.
    fn output(& self) -> Self::Output ;
    /// String representation of the output.
    fn output_str(& self) -> String ;
    /// Runs a never-ending, read-eval-print loop on the system.
    fn run() -> ! {
      let mut reader = InputReader::mk() ;
      let mut state = match Self::read_init(& mut reader) {
        Ok(init) => init,
        Err(e) => {
          println!("(Error: {})", e) ;
          exit(2)
        }
      } ;
      loop {
        match state.read_next(& mut reader) {
          Ok(next) => state = next,
          Err(e) => {
            println!("(Error: {})", e) ;
            exit(2)
          }
        }
      }
    }
  }
}

/// Parsing functions.
pub mod parse {
  use helpers::{ Int, Real, Bool } ;
  use std::fmt::Display ;
  use std::str::FromStr ;
  /// Generic parser to factor error handling out.
  fn generic<
    Out, Error: Display, F: Fn(& str) -> Result<Out, Error>
  >(s: & str, f: F, typ3: & 'static str) -> Result<Out, String> {
    match f(s) {
      Ok(res) => Ok(res),
      Err(e) => Err(
        format!("could not parse \"{}\" as {}: {}", s, typ3, e)
      ),
    }
  }
  /// Parses a [`Bool`](../type.Bool.html).
  pub fn bool(s: & str) -> Result<Bool, String> {
    generic(
      s,
      |s| match s {
        "true" | "on" => Ok(true),
        "false" | "off" => Ok(false),
        _ => Err(
          format!("legal values: true, on, false, off")
        ),
      },
      "a bool"
    )
  }
  /// Parses an [`Int`](../type.Int.html).
  pub fn int(s: & str) -> Result<Int, String> {
    generic(s, |s| Int::from_str(s), "an int")
  }
  /// Parses a [`Real`](../type.Real.html).
  pub fn real(s: & str) -> Result<Real, String> {
    generic(s, |s| Real::from_str(s), "a real")
  }
}


